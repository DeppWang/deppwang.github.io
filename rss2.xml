<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>德普王</title>
    <link>https://depp.wang/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>每个人都需要有自己的哈姆雷特</description>
    <pubDate>Thu, 12 Feb 2026 05:56:39 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Readwise Reader，一个愿意打开的稍后阅读工具</title>
      <link>https://depp.wang/2026/readwise-reader/</link>
      <guid>https://depp.wang/2026/readwise-reader/</guid>
      <pubDate>Tue, 10 Feb 2026 04:43:05 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;https://hexoblog.r2.depp.wang/202602101770695979.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;长久以来，我一直在寻找一个称心的稍后阅读工具。从 Pocket 到 &lt;a href=&quot;https://raindrop.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Raindrop&lt;/a&gt;，我都用过一段时间。Raindrop 存在一个矛盾的问题：它的数据永久保存功能需要付费，但如果只当收藏工具用，又有 MarkMark 等产品可替代；如果当稍后阅读工具用，付费倒也合理，可问题是——我不愿意打开它。&lt;/p&gt;
&lt;p&gt;我甚至想过自己开发一个 AI 驱动的增强版 Raindrop，加上自动标签、智能推荐、小红书式浏览……需求是真实的，但自己造轮子不现实，一个人根本做不完。&lt;/p&gt;
&lt;p&gt;直到我遇到了 &lt;a href=&quot;https://readwise.io/read&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Readwise Reader&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;一个稍后阅读工具，如果你不愿意打开，那它保存再多内容也没有意义。Reader 是我第一个愿意主动打开的稍后阅读工具，原因有三个。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://hexoblog.r2.depp.wang/202602101770695979.png" alt=""></p><p>长久以来，我一直在寻找一个称心的稍后阅读工具。从 Pocket 到 <a href="https://raindrop.io/" target="_blank" rel="noopener">Raindrop</a>，我都用过一段时间。Raindrop 存在一个矛盾的问题：它的数据永久保存功能需要付费，但如果只当收藏工具用，又有 MarkMark 等产品可替代；如果当稍后阅读工具用，付费倒也合理，可问题是——我不愿意打开它。</p><p>我甚至想过自己开发一个 AI 驱动的增强版 Raindrop，加上自动标签、智能推荐、小红书式浏览……需求是真实的，但自己造轮子不现实，一个人根本做不完。</p><p>直到我遇到了 <a href="https://readwise.io/read" target="_blank" rel="noopener">Readwise Reader</a>。</p><p>一个稍后阅读工具，如果你不愿意打开，那它保存再多内容也没有意义。Reader 是我第一个愿意主动打开的稍后阅读工具，原因有三个。</p><a id="more"></a><p>第一，阅读体验好。Raindrop 只有 List 视图，没有底部 Tab，打开它更像在翻一个收藏夹，而不是在用一个阅读工具。Reader 不一样，它的界面就是为阅读设计的，打开一篇文章，读起来舒服，让你愿意停留。</p><p>第二，操作逻辑顺。用 Raindrop 的时候，我自己建了一套标签体系来管理阅读状态：uninput（未读）、inputing（在读）、input（已读）。这套逻辑本身没问题，但每次都要手动打标签，操作起来有摩擦。而且 Raindrop 保存文章时，光标默认停在备注栏而不是标签，这些小细节堆起来，体验就差了。Reader 原生就有 Inbox（未读） → Later（在读）→ Archive（已读）的流转，和我在 Raindrop 里手动搭建的逻辑完全一致，但不需要自己建标签，拖一下或者点一下就完成状态切换。操作少了一步，使用意愿就多了一分。</p><p>第三，随机排序。打开稍后阅读工具，面对一长串收藏列表，常常不知道该读哪篇，然后就关掉了。Reader 有随机排序的功能，把收藏列表打乱，不用从头到尾按顺序挑。这个看似简单的功能，实际上解决了「打开后不知道读什么」的问题，大大降低了阅读的启动成本。</p><p>说完为什么愿意打开，再聊聊稍后阅读这件事本身。</p><p>我们喜欢探索新的、未知的内容，也喜欢有深度的文章。看到好内容，第一反应是「先存下来」，但存下来之后呢？大多数人的稍后阅读列表，最终变成了「再也不读」列表。稍后阅读的本质是一个输入流程：探索 → 阅读吸收 → 输出。它等于「未阅读 + 正在阅读」，终点是输出，越少越好。如果你的稍后阅读列表只增不减，说明流程出了问题。当列表被打乱，每次打开都能遇到不同的内容，稍后阅读就可以成为第一选择，不再无意识的是去找新的东西。</p><p>要让这个流程跑通，有一个前提：信息源要聚合在一处。我以前的状态是，文章放 Raindrop，视频留在各个平台，Twitter 的收藏内容放书签……信息分散在各处，想统一阅读根本不可能。Reader 把这些全部聚合到了一处，网页文章、RSS 订阅、Newsletter、Twitter、PDF、甚至视频，都可以在一个地方阅读和管理。只从这一处输入，阅读流程才能真正跑通。</p><p>稍后阅读解决的是「读」的问题，而永久保存解决的是「找」的问题。读过的内容，未来某天想引用、想回顾，能不能搜到？永久保存的终点是好查找，Reader 支持本地缓存和全文搜索，读过的东西不会消失。这也是稍后阅读的自然延伸——读完了，留下来，找得到。</p><p>最后聊聊 Reader 这个产品本身。</p><p>Reader 不只是一个稍后阅读工具，它的定位是聚合自定义信息输入流。你可以把它理解为稍后阅读 + RSS 阅读器 + Newsletter 收件箱，合在了一起。除了前面提到的阅读体验和状态流转，它还支持 Feed 订阅、Twitter 集成、YouTube 视频保存（带字幕文本）、阅读时高亮笔记，以及多设备同步。</p><p>顺带说一下，很多人会混淆 Readwise 和 Reader。简单来说，Readwise 是数据中枢，汇总你在各处的高亮笔记，统一管理、回顾和导出（比如同步到 Obsidian）；Reader 是阅读端，是你实际阅读的地方。在 Reader 里产生的高亮会自动同步回 Readwise。</p><p>Reader 目前的订阅费用是 $9.99/月（按年付），对比同类工具不算便宜，但如果你能一直愿意使用它，自己得到了提升，就划算。新用户有 1 个月免费试用，学生可以申请半价，邀请其他用户还能获赠 30 天（你通过<a href="https://readwise.io/i/depp.wang" target="_blank" rel="noopener">我的邀请链接</a>注册也可以额外获赠 30 天，就有 60 天)。建议先试用体验一下，两个月足够你判断它是否适合自己。</p><p>稍后阅读的终点不是收藏，而是输出。好的工具不是让你存更多，而是让你真正愿意打开、真正读完、真正用上。Reader 对我来说，就是那个让「稍后阅读」不再等于「再也不读」的工具。</p>]]></content:encoded>
      
      <comments>https://depp.wang/2026/readwise-reader/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git 部署常见分支问题</title>
      <link>https://depp.wang/2025/git-branch-deploy-pitfalls/</link>
      <guid>https://depp.wang/2025/git-branch-deploy-pitfalls/</guid>
      <pubDate>Mon, 08 Dec 2025 03:40:01 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;一、代码提交到部署分支，而导致在开发环境没有问题，而测试环境出了问题&quot;&gt;&lt;a href=&quot;#一、代码提交到部署分支，而导致在开发环境没有问题，而测试环境出了问题&quot; class=&quot;headerlink&quot; title=&quot;一、代码提交到部署分支，而导致在开发环境没有问题，而测试环境出了问题&quot;&gt;&lt;/a&gt;一、代码提交到部署分支，而导致在开发环境没有问题，而测试环境出了问题&lt;/h2&gt;&lt;p&gt;代码直接在部署分支 dev 提交了，没在功能分支提交，在 dev 环境没有问题，功能分支合并到 test 分支部署时，丢失在 dev 分支提交的代码，出现问题&lt;/p&gt;
&lt;p&gt;示例：test 环境出现单元测试问题，dev 环境没有这个问题，单元测试提交到了 dev 分支，导致 test 分支代码丢失&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="一、代码提交到部署分支，而导致在开发环境没有问题，而测试环境出了问题"><a href="#一、代码提交到部署分支，而导致在开发环境没有问题，而测试环境出了问题" class="headerlink" title="一、代码提交到部署分支，而导致在开发环境没有问题，而测试环境出了问题"></a>一、代码提交到部署分支，而导致在开发环境没有问题，而测试环境出了问题</h2><p>代码直接在部署分支 dev 提交了，没在功能分支提交，在 dev 环境没有问题，功能分支合并到 test 分支部署时，丢失在 dev 分支提交的代码，出现问题</p><p>示例：test 环境出现单元测试问题，dev 环境没有这个问题，单元测试提交到了 dev 分支，导致 test 分支代码丢失</p><a id="more"></a><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>使用规则保证正确性，而不让人来保证正确性，2 种方式解决：</p><ul><li>本地仓库设置部署分支 dev 分支禁止 commit</li><li>远程仓库设置部署分支不能推送，只能通过 pr 的方式合并代码到部署分支</li></ul><h3 id="本地仓库设置-dev-分支禁止-commit"><a href="#本地仓库设置-dev-分支禁止-commit" class="headerlink" title="本地仓库设置 dev 分支禁止 commit"></a>本地仓库设置 dev 分支禁止 commit</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim .git/hooks/pre-commit</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">branch="$(git rev-parse --abbrev-ref HEAD)"</span><br><span class="line"></span><br><span class="line">if [ "$branch" = "develop" ]; then</span><br><span class="line">  echo "Direct commits to develop branch are not allowed!"</span><br><span class="line">  echo "Please create a feature branch and submit a PR."</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x .git/hooks/pre-commit</span><br></pre></td></tr></table></figure><h2 id="二、手动部署后测试没有生效，结果发现是代码没有推送到远程分支"><a href="#二、手动部署后测试没有生效，结果发现是代码没有推送到远程分支" class="headerlink" title="二、手动部署后测试没有生效，结果发现是代码没有推送到远程分支"></a>二、手动部署后测试没有生效，结果发现是代码没有推送到远程分支</h2><p>流程化：推送代码自动触发部署，就没有不推送代码就部署的问题</p>]]></content:encoded>
      
      <comments>https://depp.wang/2025/git-branch-deploy-pitfalls/#disqus_thread</comments>
    </item>
    
    <item>
      <title>macOS 利用 LaunchAgents + GitHub 自动同步文件修改</title>
      <link>https://depp.wang/2025/macos-launchagents-git-autosync/</link>
      <guid>https://depp.wang/2025/macos-launchagents-git-autosync/</guid>
      <pubDate>Mon, 08 Dec 2025 03:40:01 GMT</pubDate>
      <description>
      
        &lt;p&gt;在多台 Mac 间同步笔记或脚本可以使用 Git ，它能帮我们保留历史、解决冲突，但手动 &lt;code&gt;git add/commit/push&lt;/code&gt; 容易忘。下面这套做法用 LaunchAgents 定时执行一个 Git 脚本，把指定仓库的修改自动提交并推送到 GitHub（或任意 Git 远端），既省事又留痕。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在多台 Mac 间同步笔记或脚本可以使用 Git ，它能帮我们保留历史、解决冲突，但手动 <code>git add/commit/push</code> 容易忘。下面这套做法用 LaunchAgents 定时执行一个 Git 脚本，把指定仓库的修改自动提交并推送到 GitHub（或任意 Git 远端），既省事又留痕。</p><a id="more"></a><h2 id="思路与准备"><a href="#思路与准备" class="headerlink" title="思路与准备"></a>思路与准备</h2><ol><li>一个可访问的 Git 仓库，例如 <code>git@github.com:demo/notes-sync.git</code>，本机已配置好 SSH Key 或 Token。</li><li>仓库路径假设为 <code>/Users/demo/Workspace/notes-sync</code>，请替换成自己的目录。</li><li>写一个自动提交脚本，再用 LaunchAgents 每隔几分钟调用一次。</li></ol><h2 id="编写自动提交脚本"><a href="#编写自动提交脚本" class="headerlink" title="编写自动提交脚本"></a>编写自动提交脚本</h2><p>新建脚本 <code>/Users/demo/Workspace/git-auto-commit.sh</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line">REPO=<span class="string">"/Users/demo/Workspace/notes-sync"</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$REPO</span>"</span> || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取远端，避免与他人改动冲突</span></span><br><span class="line">git pull --rebase origin main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只在有变更时提交，避免空提交</span></span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="string">"<span class="variable">$(git status --porcelain)</span>"</span> ]]; <span class="keyword">then</span></span><br><span class="line">  git add .</span><br><span class="line">  git commit -m <span class="string">"auto-commit: <span class="variable">$(date '+%Y-%m-%d %H:%M:%S')</span>"</span></span><br><span class="line">  git push origin main</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>赋权：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x /Users/demo/Workspace/git-auto-commit.sh</span><br></pre></td></tr></table></figure><h2 id="配置-LaunchAgents-定时执行"><a href="#配置-LaunchAgents-定时执行" class="headerlink" title="配置 LaunchAgents 定时执行"></a>配置 LaunchAgents 定时执行</h2><p>在 <code>~/Library/LaunchAgents</code> 新建 plist 文件 <code>com.demo.git-auto-commit.plist</code>：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.demo.git-auto-commit<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 每 5 分钟执行一次 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>StartInterval<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">integer</span>&gt;</span>300<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>ProgramArguments<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>/bin/zsh<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Users/demo/Workspace/git-auto-commit.sh<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 日志便于排查 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardOutPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Users/demo/Workspace/git-auto-commit.log<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardErrorPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Users/demo/Workspace/git-auto-commit-error.log<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加载与调试：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">launchctl load ~/Library/LaunchAgents/com.demo.git-auto-commit.plist</span><br><span class="line">launchctl start com.demo.git-auto-commit       <span class="comment"># 立刻跑一次</span></span><br><span class="line">launchctl list | grep git-auto-commit          <span class="comment"># 查看状态</span></span><br><span class="line">tail -f /Users/demo/Workspace/git-auto-commit.log</span><br></pre></td></tr></table></figure><p>如需停止或卸载：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">launchctl stop com.demo.git-auto-commit</span><br><span class="line">launchctl unload ~/Library/LaunchAgents/com.demo.git-auto-commit.plist</span><br></pre></td></tr></table></figure><h2 id="关键注意事项"><a href="#关键注意事项" class="headerlink" title="关键注意事项"></a>关键注意事项</h2><ul><li><strong>认证方式</strong>：优先用 SSH Key，若用 Token 写在脚本里，记得用只读权限并限制作用域，或在 Keychain 保存环境变量再在脚本里读取。</li><li><strong>分支一致性</strong>：脚本里固定 <code>main</code>（或 <code>master</code>），与远端分支保持一致；多人协作时保留 <code>git pull --rebase</code> 以减少冲突。</li><li><strong>执行频率</strong>：<code>StartInterval</code> 300 秒适合笔记类场景；频率过高会增加推送次数，可按仓库活跃度调整。</li><li><strong>忽略敏感文件</strong>：在 <code>.gitignore</code> 中排除缓存、日志、临时文件，避免不必要的提交。</li><li><strong>错误兜底</strong>：查看 <code>git-auto-commit-error.log</code>，常见问题是网络不通、权限不足或本地/远端存在冲突。</li></ul><p>这样配置后，Mac 会在后台定时把仓库的变更自动提交并推送，跨设备同步靠 Git 即可完成，同时保留完整历史记录。</p>]]></content:encoded>
      
      <comments>https://depp.wang/2025/macos-launchagents-git-autosync/#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用运动相机当摩托车行车记录仪</title>
      <link>https://depp.wang/2025/action4-dash-cam/</link>
      <guid>https://depp.wang/2025/action4-dash-cam/</guid>
      <pubDate>Mon, 17 Nov 2025 15:34:03 GMT</pubDate>
      <description>
      
        &lt;p&gt;一直骑摩托上下班，前几个月一次雨后上班被一位女司机给撞了，责任清晰，对方全责。前两天雨后下班，2 个行人过马路不走斑马线，雨后路滑，制动距离变长，差点撞到了。一旦遇到交通事故，有监控还好，没监控万一遇到特殊情况，难免扯皮。为了安全，决定还是整个行车记录仪。自己规范行车，但保不齐别人不遵守规则。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>一直骑摩托上下班，前几个月一次雨后上班被一位女司机给撞了，责任清晰，对方全责。前两天雨后下班，2 个行人过马路不走斑马线，雨后路滑，制动距离变长，差点撞到了。一旦遇到交通事故，有监控还好，没监控万一遇到特殊情况，难免扯皮。为了安全，决定还是整个行车记录仪。自己规范行车，但保不齐别人不遵守规则。</p><a id="more"></a><h2 id="2-种行车记录仪"><a href="#2-种行车记录仪" class="headerlink" title="2 种行车记录仪"></a>2 种行车记录仪</h2><ul><li>运动相机式<ul><li>缺点：每次需要离车拆装拿走，不然怕被偷</li><li>优点：还可以当「素质提升器」</li></ul></li><li>专用式（摩托车专用行车记录仪，前后摄像头 + 控制器）<ul><li>缺点：安装麻烦，需要走线安装，线要接电瓶上；防抖性可能不过关</li><li>优点：不用每次拆装</li></ul></li></ul><h3 id="运动相机"><a href="#运动相机" class="headerlink" title="运动相机"></a>运动相机</h3><p>适合的场景</p><ol><li>行车记录仪，需要防水/防抖/清晰。如果车上有充电条件（USB 口），不需要长续航，可以边录边充</li><li>素质提升器</li><li>第一次人称视角视频：如记录小孩 / 记录婚礼 / 户外 / 旅行 / 运动 / 有水的场景</li><li>自媒体博主使用（需要走路/轻便）</li><li>录音机</li></ol><p>正常运动相机效果没有手机好，不适合场景</p><ul><li>拍照</li><li>夜景</li><li>不动场景拍视频等</li></ul><h3 id="手机当行车记录仪"><a href="#手机当行车记录仪" class="headerlink" title="手机当行车记录仪"></a>手机当行车记录仪</h3><p>优势</p><ol><li>省钱，不用额外购买设备</li><li>拆装方便</li></ol><p>要解决的问题</p><ol><li>防抖。如果直接安装在摩托车车头手机支架上</li><li>防水。下雨天使用，一般都是下雨时容易交通事故</li><li>安全。不建议使用贵重手机，摩托车的机震可能导致手机摄像头光学防抖损坏。建议使用没有光学防抖的闲置手机</li></ol><p>摩托车的机震可能导致手机摄像头光学防抖损坏，我也是最近才知道这个知识点。如果行驶过程中还录像，因为光学防抖会主动矫正摄像头，那会加速光学防抖损坏。</p><p>即使不在行驶过程中使用手机录像，也会经常使用手机导航，虽然不使用手机录像相比使用手机录像时机震影响要小很多，但是还是有一定风险。最好还是使用个减震的手机支架，我试用了下<a href="https://item.jd.com/100038132157.html" target="_blank" rel="noopener">摩多狼的减震支架</a>，但发现没有用，减震固定得太死了，找摩友要了他正在使用的「<a href="https://m.tb.cn/h.Su3Pmsl" target="_blank" rel="noopener">灯昕磁悬浮减震支架</a>」，减震可以灵活移动，效果要好不少。</p><p>不过最好不使用手机导航时揣兜里，人体的减震性最好。</p><h2 id="运动相比对比"><a href="#运动相比对比" class="headerlink" title="运动相比对比"></a>运动相比对比</h2><p>山狗与其它运动相机没有裸机防水功能而没有考虑。主要考虑大疆与速影 C200 系列。纠结的点主要在于大疆的价格，觉得 1000 多的售价，与基本只做行车记录仪的定位有点不匹配。看到了速影 C200 系列，就买来对比了下。</p><h3 id="速影-C200-系列"><a href="#速影-C200-系列" class="headerlink" title="速影 C200 系列"></a>速影 C200 系列</h3><p>特点</p><ol><li>支持裸机防水</li><li>有行车记录仪模式（通电开启录像，无电自动停止录像并关机）</li><li>有 2 小时续航</li><li>有记忆功能，上次设置的数据会保存</li><li>使用 A1 内存卡即可</li></ol><p>注意点</p><ol><li>防抖开了会裁剪画面</li><li>防抖与鱼眼矫正不能一起用<ul><li>应该是防抖与鱼眼矫正都是画面裁剪，都开启画面更少，所以不能一起用</li></ul></li><li>带边框时可以充电，充电口盖子可以取下</li></ol><p>价格</p><ul><li>速影 C200：京东国补后 335 </li><li>速影 C200 PRO：京东国补后 539 </li></ul><h3 id="C200-vs-C200-PRO"><a href="#C200-vs-C200-PRO" class="headerlink" title="C200 vs C200 PRO"></a>C200 vs C200 PRO</h3><p>C200 优势：便宜 200</p><p>C200 PRO 优势：</p><ol><li>可触控操作，更方面。C200 只能按键操作</li><li>实测更清晰，晚上车库测试，能看清楚车牌</li></ol><p>实测 2 个防抖都不太行，直接安装在摩托车镜座支架上都不太可用</p><h3 id="C200-PRO-vs-Action4"><a href="#C200-PRO-vs-Action4" class="headerlink" title="C200 PRO vs Action4"></a>C200 PRO vs Action4</h3><p>C200 PRO 优势</p><ol><li>便宜 650</li><li>更轻 (裸机 88g / 加边框 105g) ( Action4 裸机 147g /  加边框 188g)</li><li>有车载模式</li><li>有防水充电线，可以雨天充电使用</li><li>拍摄视频所占内存更小</li><li>可以直接在视频上打上时间戳</li><li>循环录制自动按指定时间视频分段，大疆的循环录制是只录制指定分钟数</li><li>可以循环录影，内存满了自动删除之前</li></ol><p>Action4 优势</p><ol><li>更清晰</li><li>实测防抖效果好一点（开启电子增稳定）：直接安装在镜座上录像相对更清晰点</li><li>易用性更好<ul><li>边框可以不拆时充电，不充电时盖住防水/防尘</li><li>横竖屏拍摄可以不用手动调整</li><li>机器可以查看具体电量数值</li><li>连接设备更方面，可以搜索连接，不用每次扫码</li><li>可以手机 APP 查看视频拍摄时间，C200 系列需要视频有水印才能看出来</li><li>可直接按键切换拍照/视频</li><li>有快充</li></ul></li><li>赠送配件可直接磁吸快拆，不用额外购买<a href="https://u.jd.com/WOiBpLG" target="_blank" rel="noopener">磁吸快拆</a>；赠送配件头盔粘胶可以直接使用</li><li>颜值高点，产品质量可能会好点</li><li>下载视频到手机速度更快</li><li>可手机 APP 编辑视频、可以更换电池、双屏</li></ol><p>两者都不能云端自动备份，不能丢失时也能看到之前录制视频。</p><p>C200 系列因为有车载模式 / 有防水充电线，更适合直接固定安装在车上，但其防抖性不太行， 可能配置个<a href="https://m.tb.cn/h.Suk5U0k" target="_blank" rel="noopener">运动相机减震支架</a>会好点。但如果不安装在车上使用，其车载模式与防水充电线优势也就没了。又多了劣势：如果不取掉充电口盖子，不太易用，每次充电要拆边框。取掉了又没有了防水的优势。</p><p>Action4 相比有了防抖优势，可以配合<a href="https://u.jd.com/Wri91bU" target="_blank" rel="noopener">支架</a>直接安装在车上使用，也可以使用挂脖与安装上头盔上使用，当不安装在车上使用时，也不需要车载模式与防水充电线。</p><p>我想平时还是挂脖使用，离车后也可以连续录制。最后天猫买了大疆，总价 1220，1170 +  50 <a href="https://u.jd.com/WGi5KZK" target="_blank" rel="noopener">挂脖支架</a>，原来有 A2 内存卡。</p><h3 id="大疆-Action4-各平台对比"><a href="#大疆-Action4-各平台对比" class="headerlink" title="大疆 Action4 各平台对比"></a>大疆 Action4 各平台对比</h3><p>天猫旗舰店</p><ul><li>优势：<ul><li>价格 1170，原价 1248，直播间购买 -50，用了些淘金币</li><li>双十一可激活试用 30 天</li></ul></li></ul><p>京东</p><ul><li>劣势：<ul><li>价格 1248</li><li>不能试用，拆了就不能退</li></ul></li></ul><p>拼多多</p><ul><li>优势：价格 1157</li><li>劣势：虽然标记的「品牌好货」，如果运气不买，买到瑕疵机器，售后可能不省心，赠送的随心换还要找客服单独领取激活。</li><li>机器：应该都是正品，可以通过大疆官方查验</li></ul><p>PS：拼多多「品牌好货」不是拼多多自营的，拼多多的「品牌好货」是聚合的三方商家店铺，只提供了一个「品牌好货」的入口，消费者看不了具体的三方店铺信息，客服也第三方店铺的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>只当行车记录仪可以上 C200，使用相对防盗的方式直接安装上车上。满足基本行车记录仪需求，可以区分事故责任，晚上可能看不清车牌号，防抖性一般。或者直接买更便宜不防水的汽车行车记录仪，自己 DIY 一下。</p><p>如果考虑还会拍点东西，建议直接上 Action4。其颜值更高，更愿意拿出去拍，易用性也很好。C200 PRO 有点不上不下，当运动相机拍可能功能不太够；安装上车上防抖跟 C200 差不多，有点划不来。贵的东西除了贵，确实优点更多。而大疆 Action4 做行车记录仪，完全够用了，完全不用什么 Action5 PRO 什么的了。</p><p>下大雨或者可视距离变少同时又下雨（如晚上下雨）的情况建议还是不要骑摩托车了，使用其它交通工具更安全。</p><p>顺便说一句，大疆还是有点格局的，可以激活试用。在中国，像京东/大疆这样的大厂，还是越多越好。</p>]]></content:encoded>
      
      <comments>https://depp.wang/2025/action4-dash-cam/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Apple TV 上使用 RetroArch 玩魂斗罗</title>
      <link>https://depp.wang/2025/apple-tv-contra/</link>
      <guid>https://depp.wang/2025/apple-tv-contra/</guid>
      <pubDate>Sat, 01 Nov 2025 08:15:40 GMT</pubDate>
      <description>
      
        &lt;p&gt;我 Apple TV 现在是配合极米投影仪在使用，现在基本只偶尔使用 VLC + NAS 看电影。买过一段时间 Arcade 玩游戏，玩的频率不高加上订阅制不太划算，Apple TV 就只用来看电影了。&lt;/p&gt;
&lt;p&gt;前两天突然想到能不能 Apple TV 玩下小时候的魂斗罗之类的游戏，折腾试了一下，还真可以。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexoblog.r2.depp.wang/202511011761977571.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>我 Apple TV 现在是配合极米投影仪在使用，现在基本只偶尔使用 VLC + NAS 看电影。买过一段时间 Arcade 玩游戏，玩的频率不高加上订阅制不太划算，Apple TV 就只用来看电影了。</p><p>前两天突然想到能不能 Apple TV 玩下小时候的魂斗罗之类的游戏，折腾试了一下，还真可以。</p><p><img src="https://hexoblog.r2.depp.wang/202511011761977571.jpeg" alt=""></p><a id="more"></a><p>我是使用的 <a href="https://github.com/libretro/RetroArch" target="_blank" rel="noopener">RetroArch</a> 实现的，可以按这 2 个视频教程操作，讲得挺详细。</p><ol><li><a href="https://www.bilibili.com/video/BV1oH4y1g7bA/" target="_blank" rel="noopener">BiliBili - 全能模拟器RetroArch苹果AppleTV客户端使用教程</a></li><li><a href="https://www.youtube.com/watch?v=KxcBHevoqhE" target="_blank" rel="noopener">YouTube - Retro Gaming on the Apple TV 4K (Guide)</a></li></ol><p>RetroArch 的核心 Core 是模拟原来经典游戏主机的模拟主机系统，它提供一系列 Core，可以模拟原来各种经典游戏的主机，是一个 Core 集合，但它不提供具体的游戏，需要你自己去找。</p><h2 id="在-使用-RetroArch-遇到的几个问题"><a href="#在-使用-RetroArch-遇到的几个问题" class="headerlink" title="在 使用 RetroArch 遇到的几个问题"></a>在 使用 RetroArch 遇到的几个问题</h2><h3 id="1、游戏资源问题"><a href="#1、游戏资源问题" class="headerlink" title="1、游戏资源问题"></a>1、游戏资源问题</h3><p>这几个网站的资源实测可用：</p><ol><li><a href="https://www.emu-land.net/en/consoles/dendy/roms/top" target="_blank" rel="noopener">https://www.emu-land.net/en/consoles/dendy/roms/top</a> : 这个网站好像晚上不能下载，要白天才行</li><li><a href="https://github.com/dream1986/nesrom" target="_blank" rel="noopener">https://github.com/dream1986/nesrom</a></li><li><a href="https://forum.ubuntu.org.cn/viewtopic.php?t=202700" target="_blank" rel="noopener">https://forum.ubuntu.org.cn/viewtopic.php?t=202700</a> 破解版</li></ol><h3 id="2、-IP-打不开的问题"><a href="#2、-IP-打不开的问题" class="headerlink" title="2、 IP 打不开的问题"></a>2、 IP 打不开的问题</h3><p><img src="https://hexoblog.r2.depp.wang/202511011761981220.jpeg" alt=""></p><p>因为 tvOS 本身没有 Files APP，RetroArch 是利用 tvOS 的 80 端口，即 Apple TV 对应 IP 地址 ( <a href="http://192.168.31.111/" target="_blank" rel="noopener">http://192.168.31.111/</a> ) 上传资源  。当打开 RetroArch 时，就会弹出这个提示。同一个局域网的其它设备或者说连同一个 WIFI 的设置，可以直接通过这个地址上传游戏资源。</p><p>但需要注意：要使用 Safari 浏览器打开这个地址，我使用 Chrome 就打不开，折腾半天。</p><h3 id="3-超级马里奥跳不高的问题"><a href="#3-超级马里奥跳不高的问题" class="headerlink" title="3. 超级马里奥跳不高的问题"></a>3. 超级马里奥跳不高的问题</h3><p>在玩「超级马里奥」时发现「跳跃键」跳不高，换了个游戏资源也不行，最后发现是输入映射时不小心将跳跃键键映射到了 Turbo 这个键上，按 Y 键取消映射了就好了。</p><p><img src="https://hexoblog.r2.depp.wang/202511011761981390.jpeg" alt=""></p><h2 id="ROM-文件-nes-与核心-FCEUmm-Nestopia-之间的关系"><a href="#ROM-文件-nes-与核心-FCEUmm-Nestopia-之间的关系" class="headerlink" title="ROM 文件 nes 与核心 FCEUmm / Nestopia 之间的关系"></a>ROM 文件 nes 与核心 FCEUmm / Nestopia 之间的关系</h2><p><img src="https://hexoblog.r2.depp.wang/202511011761977548.jpeg" alt=""></p><blockquote><p><strong>FC游戏机</strong>，是<a href="https://zh.wikipedia.org/wiki/%E4%BB%BB%E5%A4%A9%E5%A0%82" title="任天堂" target="_blank" rel="noopener">任天堂</a>（Nintendo）生产、发行和销售的<a href="https://zh.wikipedia.org/wiki/8%E4%BD%8D%E5%85%83" title="8位" target="_blank" rel="noopener">8位</a><a href="https://zh.wikipedia.org/wiki/%E7%AC%AC%E4%B8%89%E4%B8%96%E4%BB%A3%E9%81%8A%E6%88%B2%E6%A9%9F" title="第三世代游戏机" target="_blank" rel="noopener">第三世代</a><a href="https://zh.wikipedia.org/wiki/%E5%AE%B6%E7%94%A8%E6%B8%B8%E6%88%8F%E6%9C%BA" title="家用游戏机" target="_blank" rel="noopener">家用游戏机</a>。日本版官方名称为<strong>家庭电脑</strong>（日版名：ファミリーコンピュータ，Family Computer，<strong>Famicom</strong>），俗称“<strong>红白机</strong>”，1983年7月15日在日本推出；欧美版名称为<strong>任天堂娱乐系统</strong>（英文版名：Nintendo Entertainment System，<strong>NES</strong>），俗称“<strong>灰机</strong>”，1985年10月18日在美国推出。</p></blockquote><p>所以：</p><ul><li>核心 Core 是模拟主机系统，ROM 文件是游戏镜像</li><li>Famicom / NES 都是使用 .nes ROM 文件</li><li><a href="https://github.com/libretro/libretro-fceumm" target="_blank" rel="noopener">FCEUmm</a> 与 <a href="https://github.com/libretro/nestopia" target="_blank" rel="noopener">Nestopia</a> 都可以运行 .nes ROM 文件，都支持 Famicom 和 NES </li><li>核心 FCEUmm「仿真精准、音画最接近原机」，核心 Nestopia「性能轻快、兼容性好、支持作弊/快进」，我但没感觉出区别</li></ul><table><thead><tr><th>FC</th><th>NES</th></tr></thead><tbody><tr><td><img src="https://hexoblog.r2.depp.wang/202511011761972134.png" alt=""></td><td><img src="https://hexoblog.r2.depp.wang/202511011761972141.png" alt=""></td></tr></tbody></table><h2 id="游戏图片"><a href="#游戏图片" class="headerlink" title="游戏图片"></a>游戏图片</h2><p><img src="https://hexoblog.r2.depp.wang/202511011761981448.jpeg" alt=""></p><p><img src="https://hexoblog.r2.depp.wang/202511011761981460.jpeg" alt=""></p><ul><li>影之传说</li></ul>]]></content:encoded>
      
      <comments>https://depp.wang/2025/apple-tv-contra/#disqus_thread</comments>
    </item>
    
    <item>
      <title>从羽毛球启发的「后端工程师等级说明」</title>
      <link>https://depp.wang/2025/backend-engineer-level-guide/</link>
      <guid>https://depp.wang/2025/backend-engineer-level-guide/</guid>
      <pubDate>Fri, 24 Oct 2025 13:45:11 GMT</pubDate>
      <description>
      
        &lt;p&gt;现在经常在打羽毛球，羽毛球等级森严，级别差太多根本没法打，只要差上半级，差的这边肯定打不过，差上两级，双方就没有体验感。有一位名叫「波澜不惊」的网友写了个很好的「业余羽毛球等级说明」，对级别的描述很精确，对每个等级具体需要掌握什么技术与这个等级的特点写得很清楚。&lt;/p&gt;
&lt;p&gt;我作为软件后端工程师，虽然我们也有初级/中级/高级工程师的划分，但每个级别具体需要掌握什么，界限往往很模糊。我就在想能不能像羽毛球等级一样，也做一个「后端工程师等级说明」？这样既能认清自己的水平，也能更有针对性地进步。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>现在经常在打羽毛球，羽毛球等级森严，级别差太多根本没法打，只要差上半级，差的这边肯定打不过，差上两级，双方就没有体验感。有一位名叫「波澜不惊」的网友写了个很好的「业余羽毛球等级说明」，对级别的描述很精确，对每个等级具体需要掌握什么技术与这个等级的特点写得很清楚。</p><p>我作为软件后端工程师，虽然我们也有初级/中级/高级工程师的划分，但每个级别具体需要掌握什么，界限往往很模糊。我就在想能不能像羽毛球等级一样，也做一个「后端工程师等级说明」？这样既能认清自己的水平，也能更有针对性地进步。</p><a id="more"></a><h2 id="2025-业余羽毛球等级说明"><a href="#2025-业余羽毛球等级说明" class="headerlink" title="2025 业余羽毛球等级说明"></a>2025 业余羽毛球等级说明</h2><p><img src="https://hexoblog.r2.depp.wang/202504111744362529.jpg" alt=""></p><h2 id="两个等级之间的映射"><a href="#两个等级之间的映射" class="headerlink" title="两个等级之间的映射"></a>两个等级之间的映射</h2><p>对于业余羽毛球初学者来说，正常的学习顺序是技术 -&gt; 脚步 -&gt; 球路 -&gt; 体能，对应后端工程师，我将其它映射为技术 -&gt; 业务 -&gt; 架构 -&gt; 兴趣。</p><p>羽毛球技术：握拍 / 发球 / 正手高远球 / 反手高远球 / 杀球 / 吊球，映射为后端工程师技术：编程语言 / 框架 / 数据库 / 缓存 / 中间件 / 容器化。其它一些技术如「勾搓扑挑」等映射为对工具的掌握，如「IDE、Linux Command、Git、Maven」等</p><h2 id="后端工程师等级说明"><a href="#后端工程师等级说明" class="headerlink" title="后端工程师等级说明"></a>后端工程师等级说明</h2><h3 id="0-5-级：刚接触编程"><a href="#0-5-级：刚接触编程" class="headerlink" title="0.5 级：刚接触编程"></a>0.5 级：刚接触编程</h3><p>对应羽毛球室外打球阶段，核心特征是会刚接触编程。对 IDE、Git、Shell 等工具几乎陌生，只能照着教材输出“Hello World”，还分不清接口、数据库、部署之间的关系，只求代码能跑起来。</p><h3 id="1-0-级：会点编程语言"><a href="#1-0-级：会点编程语言" class="headerlink" title="1.0 级：会点编程语言"></a>1.0 级：会点编程语言</h3><p>对应羽毛球会握拍阶段，核心特征是会点编程语言。开始使用 IDE，能写变量、条件、循环、集合等基础特性，偶尔能写出小算法，可以照需求描述实现简单脚本或 demo，对数据库、缓存等还不太了解。</p><h3 id="1-5-级：会使用框架"><a href="#1-5-级：会使用框架" class="headerlink" title="1.5 级：会使用框架"></a>1.5 级：会使用框架</h3><p>对应羽毛球会发球阶段，核心特征是会使用一种基础框架（如 Spring Boot）。开始理解接口开发的 POST GET 的区别，了解 Maven 命令，还不太会写数据库 SQL，还不能进行简单的业务开发。</p><h3 id="2-0-级：初级工程师（大学毕业生水平）"><a href="#2-0-级：初级工程师（大学毕业生水平）" class="headerlink" title="2.0 级：初级工程师（大学毕业生水平）"></a>2.0 级：初级工程师（大学毕业生水平）</h3><p>对应羽毛球会打高远球阶段，核心特征是会能在指导下完成简单需求开发。会使用 MySQL 数据库，会写一些简单的 SQL，会使用 Git 。了解 MVC 开发，理解 ORM 等概念。能在指导下完成简单需求开发与 bug 修改，对表结构、用户登录原理与 Session 机制有初步认识。这个阶段更多是编码实现，也开始建立自己「实验室」通过 demo 代码实现各个技术点。</p><ul><li>「大学毕业生水平」：我觉得是一般计算机专业刚毕业的学生就差不多这个等级</li></ul><h3 id="2-5-级：初级工程师"><a href="#2-5-级：初级工程师" class="headerlink" title="2.5 级：初级工程师+"></a>2.5 级：初级工程师+</h3><p>对应羽毛球小对抗、会挑球 / 偶尔会吊球阶段，核心特征是能在指导下完成小模块开发。技术上熟练使用主力语言、框架、MySQL 关系数据库，会使用基础的 Linux 命令，理解 Git 原理。可以写简单 CURD 增删改查代码，但 Bug 较多。</p><h3 id="3-0-级：中级工程师（高水平大学毕业生）"><a href="#3-0-级：中级工程师（高水平大学毕业生）" class="headerlink" title="3.0 级：中级工程师（高水平大学毕业生）"></a>3.0 级：中级工程师（高水平大学毕业生）</h3><p>对应羽毛球小对抗、会杀球 / 吊球阶段，核心特征是能在指导下完成中等模块开发，能独立完成小模块开发与设计。技术上会使用常用中间件，会用缓存 Redis，理解 Maven 原理，理解 Spring 框架的核心原理，熟悉 Docker 基本用法。业务上熟悉基本的 API 设计，可独立设计 API；熟悉数据库设计，可以独立设计数据库表；有一定业务抽象能力，可以将简单业务抽象为数据库表结构与 API，会写单元测试；理解用户登录原理。开始形成以完成一个让别人 / 用户来用的比较完整的软件功能为主的「工作室」。</p><ul><li>「高水平大学毕业生」：在学校学得好的，大学刚毕业就直接在这个等级</li></ul><h3 id="3-5-级：中级工程师"><a href="#3-5-级：中级工程师" class="headerlink" title="3.5 级：中级工程师+"></a>3.5 级：中级工程师+</h3><p>对应羽毛球中对抗、会反手高远球阶段，核心特征是能在指导下完成中大模块开发，能独立完成中小模块开发与设计。技术上熟练使用 Redis，熟练使用常用中间件，如 Kafka。具备初步的业务设计模式意识，不只是按需求实现，开始理解业务需求背后真实的意图，可以指出需求中问题，帮助需求闭环。知道需求的优先级与重要性，合理分配精力与时间。开始对安全编程有一定想法与实现，代码不只是考虑功能实现。 开发的功能维护性在中等水平。可以快速定位独立解决中等难度的技术问题。开始建立起来对自己技术的自信。</p><h3 id="4-0-级：高级工程师"><a href="#4-0-级：高级工程师" class="headerlink" title="4.0 级：高级工程师"></a>4.0 级：高级工程师</h3><p>对应羽毛球中对抗、普通大学校队水平、掌握各种杀球/吊球的阶段，核心特征是能独立完成中等模块功能的设计与开发。技术上掌握部分中间件原理，掌握 Docker 容器化原理，阅读过其源码。掌握数据库、Redis 关键机制。业务上可以快速的熟悉与理解新业务，并完成从需求分析、方案设计、编码上线工作。写的代码质量好，bug 少。开始在团队内形成个人影响力。开始建立自己的「工厂」，相比「工作室」，「工厂」有一整套的规范和标准。</p><h3 id="4-5-级：-高级工程师"><a href="#4-5-级：-高级工程师" class="headerlink" title="4.5 级： 高级工程师 +"></a>4.5 级： 高级工程师 +</h3><p>对应羽毛球大对抗、普通大学校队主力水平、会跳杀的阶段，核心特征是能独立完成大模块功能的设计与开发，独立解决复杂技术问题。技术上掌握中间件核心原理，从源码上理解。写的代码 Bug 非常少。各种业务系统的实现方式都已掌握，编码熟练使用各种设计模式，业务实现简洁但稳定，实现不仅考虑功能还兼顾安全，能承担核心技术攻关。开始发现现有架构的不足。这个等级需要掌握计算机基础知识，不然到不了这个级别。在团队内形成稳定的个人影响力。</p><p>PS：羽毛球技术的核心是通透的发力，后端工程师技术的核心我认为是计算机基础。发力可以分为：手指发力、手腕发力、内旋发力、鞭打发力、腰腹发力、全身发力。计算机基础可以分为： 计算机组成原理、Linux 操作系统，编译原理、网络原理、数据结构与算法等。业务球友不掌握发力，可以到 4.0 级，但绝对到不到 4.5 级。同样，我认为后端工程师不掌握计算机基础可以到高级工程师，但绝对到不了「高级工程师 +」这个等级。</p><h3 id="5-0-级：技术专家"><a href="#5-0-级：技术专家" class="headerlink" title="5.0 级：技术专家"></a>5.0 级：技术专家</h3><p>对应羽毛球大对抗、普通教练水平阶段，核心特征是可以根据需要修改、扩展、优化架构。高级工程师主要是在已有的架构框架下完成设计，而技术专家会根据需要修改、扩展、优化架构。各种技术运用自如，熟练运用各种技术完成业务开发。并且有一两项突出的技术，比如对 Redis 的研究非常深，给它贡献过核心代码。可以快速定位独立解决很复杂的问题。独立开发与团队配合都很好，几乎是没有 bug 的。系统安全做得好。在团队内形成极强的个人影响力</p><h3 id="6-0-级：初级架构师"><a href="#6-0-级：初级架构师" class="headerlink" title="6.0 级：初级架构师"></a>6.0 级：初级架构师</h3><p>对应羽毛球比赛级、地区普通组冠军水平阶段，核心特征是独立完成一个系统的架构设计。可以是从 0 到 1 设计一个新系统，也可以是将架构从 1.0 重构到 2.0。初级架构师负责的系统复杂度相对来说不高，例如后台管理系统、某个业务下的子系统、100 万 PV 量级的网站等。6.0 级别要么初级架构师，要么就是技术 leader，可以带一个小团队，开始有团队影响力。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>做这么一个等级表不容易，涉及不少东西，写了很久，但水平有限，可能不太准确。本来让 AI 写，不太满意，全部手敲。后面可能不定时更新这个等级表。</p><p>后端工程师依次提升的 4 维度是技术、业务、架构、兴趣，而针对全栈工程师（独立开发），4 个维度又不太一样，我认为是技术、产品、需求、推广。每个职业都有自己的 4 维度划分。</p><p>还有一点小感受，学习计算机技术与学习羽毛球技术一样，关键是要有成就感，要有瘾，也就是正反馈，所以这就是需要有正确的方式与路线来学习，每个人情况不一样，需要找到最适合自己的方式与路线。</p><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><ul><li><a href="https://time.geekbang.org/learning/path-detail/16" target="_blank" rel="noopener">极客时间 - 后端工程师 - 学习路线</a></li><li><a href="https://time.geekbang.org/column/article/242946" target="_blank" rel="noopener">陈皓 - 左耳听风 - 91 | 程序员练级攻略的正确打开方式</a></li><li><a href="https://cn.linkedin.com/pulse/%E7%A1%85%E8%B0%B7%E5%A4%9C%E8%B0%88%E4%BA%8C%E4%BA%94%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E5%BF%83%E5%BE%97-john-di-wu" target="_blank" rel="noopener">Di Wu - 硅谷夜谈（二）：五级软件工程师修炼心得</a></li></ul>]]></content:encoded>
      
      <comments>https://depp.wang/2025/backend-engineer-level-guide/#disqus_thread</comments>
    </item>
    
    <item>
      <title>注意力保卫战，我的注意力管理实践</title>
      <link>https://depp.wang/2025/attention/</link>
      <guid>https://depp.wang/2025/attention/</guid>
      <pubDate>Fri, 15 Aug 2025 15:05:30 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/main-11.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;注意力是这个时代最稀缺的资源&quot;&gt;&lt;a href=&quot;#注意力是这个时代最稀缺的资源&quot; class=&quot;headerlink&quot; title=&quot;注意力是这个时代最稀缺的资源&quot;&gt;&lt;/a&gt;注意力是这个时代最稀缺的资源&lt;/h2&gt;&lt;p&gt;打开手机，短视频软件在推送今天的热点，社交软件的红点提醒你有新消息，游戏的活动通知吸引你再玩一局。我们生活在一个注意力被无限分割的时代。&lt;/p&gt;
&lt;p&gt;每个人每天的注意力总量是有限的，就像手机电池一样，用一点就少一点。当我们把注意力过多地消耗在娱乐和消遣上，留给工作、学习和成长的注意力自然就减少了。更糟糕的是，频繁的注意力切换会让大脑疲惫，即使想要专注时也难以进入状态。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/main-11.jpg" alt=""></p><h2 id="注意力是这个时代最稀缺的资源"><a href="#注意力是这个时代最稀缺的资源" class="headerlink" title="注意力是这个时代最稀缺的资源"></a>注意力是这个时代最稀缺的资源</h2><p>打开手机，短视频软件在推送今天的热点，社交软件的红点提醒你有新消息，游戏的活动通知吸引你再玩一局。我们生活在一个注意力被无限分割的时代。</p><p>每个人每天的注意力总量是有限的，就像手机电池一样，用一点就少一点。当我们把注意力过多地消耗在娱乐和消遣上，留给工作、学习和成长的注意力自然就减少了。更糟糕的是，频繁的注意力切换会让大脑疲惫，即使想要专注时也难以进入状态。</p><a id="more"></a><h2 id="影响专注的客观因素"><a href="#影响专注的客观因素" class="headerlink" title="影响专注的客观因素"></a>影响专注的客观因素</h2><p>有时候无法集中注意力并不完全是意志力的问题，一些客观因素确实会影响我们的专注能力：</p><ul><li>前一天没睡好，大脑处于疲劳状态</li><li>饭后血糖升高，身体启动消化程序，容易犯困</li><li>中午没有小憩，下午精力不足</li></ul><p>这些客观因素虽然存在，但相对还是比较少的。更多时候，是我们主动选择了分心。</p><h2 id="正视人性的弱点"><a href="#正视人性的弱点" class="headerlink" title="正视人性的弱点"></a>正视人性的弱点</h2><p>人性是有弱点的，我们的大脑天生喜欢轻松愉悦的事物。刷短视频、追热点、看资讯，这些活动不需要深度思考，还能带来即时的满足感。经不住诱惑是正常的，关键是要认识到这一点，然后主动创造一个减少诱惑的环境。</p><p>与其依靠意志力对抗诱惑，不如从源头上减少诱惑的出现。</p><h2 id="减少注意力分散的具体方法"><a href="#减少注意力分散的具体方法" class="headerlink" title="减少注意力分散的具体方法"></a>减少注意力分散的具体方法</h2><h3 id="智能手机管理"><a href="#智能手机管理" class="headerlink" title="智能手机管理"></a>智能手机管理</h3><p><strong>断舍离策略</strong></p><ol><li>不安装某些短视频软件，如快手、抖音</li><li>卸载 APP，改用网页版本，增加使用门槛，如 X(Twitter)</li><li>睡觉时手机不带进卧室，避免睡前刷手机和早起第一件事就是看手机</li><li>隐藏微信 APP 的朋友圈、视频号、搜一搜、看一看等分散注意力的功能</li></ol><p><strong>iPhone 专属技巧</strong>（安卓应该也能实现）</p><ol><li>有时需要查点东西但不想频繁打开的，如小红书，可以卸载后使用<a href="https://www.icloud.com/shortcuts/02e36298e02946e3acdcb8bd138332fb" target="_blank" rel="noopener">快捷指令</a>进行网页搜索</li><li>使用 APP 隐藏模式，将 BiliBili 等娱乐软件放入隐藏文件夹</li><li>开启「屏幕使用时间」，给特定 APP 设置每日使用限额</li><li>开启色彩过滤器，将手机调成黑白模式，降低视觉吸引力</li></ol><h3 id="电脑端防护"><a href="#电脑端防护" class="headerlink" title="电脑端防护"></a>电脑端防护</h3><ol><li>安装 BiliBili 自律插件：<a href="https://chromewebstore.google.com/detail/productivitibili-hide-bil/kbeeegjjikobknoihlpjmebhcolfmdoj" target="_blank" rel="noopener">ProductivitiBili</a>，过滤首页推荐</li><li>使用 YouTube 插件：<a href="https://chromewebstore.google.com/detail/clean-youtube-hide-youtub/kalhfjomailhflienkfajocjodgjipie" target="_blank" rel="noopener">Clean YouTube</a>，隐藏推荐视频</li><li>安装搜索优化插件：<a href="https://github.com/langren1353/GM_script" target="_blank" rel="noopener">AC-baidu</a>，过滤百度等搜索引擎的广告</li><li>工作时关闭微信桌面端，使用智能手表接收重要通知</li></ol><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><ol><li>使用数据统计来自我督促，如 GitHub 统计图、微信阅读时长 Weight（iPhone）</li><li>突然想到或者想做的事，建立待办事项清单，避免注意力切换</li><li>按优先级处理任务，永远先做最重要的事</li><li>专注时开启勿扰模式，屏蔽非紧急通知</li></ol><h2 id="建立自己的信息源"><a href="#建立自己的信息源" class="headerlink" title="建立自己的信息源"></a>建立自己的信息源</h2><p>正因为大脑天生喜欢轻松愉悦的事物，所以我们不可能不去做不用脑的事。但我们可以主动构建自己的信息获取渠道，避免被动接受算法推送。比如：</p><p><strong>资讯与新闻</strong></p><ul><li><a href="https://china.nba.cn/news" target="_blank" rel="noopener">NBA 中国官方网站</a> - NBA 新闻</li><li><a href="https://www.badmintoncn.com/" target="_blank" rel="noopener">中羽在线</a> - 羽毛球资讯</li><li><a href="https://www.bbc.com/zhongwen/simp" target="_blank" rel="noopener">BBC</a>、<a href="https://cn.nytimes.com/" target="_blank" rel="noopener">NYTimes</a> - 新闻</li><li><a href="https://news.ycombinator.com/" target="_blank" rel="noopener">Hacker News</a> - 科技资讯</li></ul><p><strong>稍后阅读</strong></p><ul><li><a href="https://www.youtube.com/playlist?list=WL" target="_blank" rel="noopener">YouTube 稍后观看</a> / <a href="https://www.bilibili.com/watchlater/list" target="_blank" rel="noopener">BiliBili 稍后观看</a> - 个人稍后观看</li><li><a href="https://app.raindrop.io/my/0" target="_blank" rel="noopener">Raindrop.io</a> - 文章稍后阅读与收藏</li><li><a href="https://x.com/i/bookmarks" target="_blank" rel="noopener">X 个人书签</a> - Twiiter 个人收藏</li></ul><p><strong>个人关注</strong></p><ul><li><a href="https://yixi.tv/" target="_blank" rel="noopener">一席</a> - 高质量中文演讲</li><li><a href="https://feeder.co/reader" target="_blank" rel="noopener">Feeder</a> - 个人 RSS 订阅管理</li><li><a href="https://github.com/trending" target="_blank" rel="noopener">GitHub Trending</a>- 开源项目趋势</li></ul><h2 id="专注的复利效应"><a href="#专注的复利效应" class="headerlink" title="专注的复利效应"></a>专注的复利效应</h2><p>成长的速度，取决于专注的时间。</p><p>当我们能够持续专注地投入到一件事情上，不仅能够产出更高质量的成果，还能进入心流状态，体验到深度工作带来的满足感。这种满足感远比刷短视频等获得的即时快感更持久、更有价值。</p><p>每一次选择专注而非分心，都是对未来的自己的投资。这些投资会像复利一样累积，最终带来质的飞跃。在这个注意力稀缺的时代，能够掌控自己注意力的人，才能真正掌控自己的人生。</p>]]></content:encoded>
      
      <comments>https://depp.wang/2025/attention/#disqus_thread</comments>
    </item>
    
    <item>
      <title>900 元一个月的编程助手值不值？Claude Code 真实使用体验</title>
      <link>https://depp.wang/2025/claude-code/</link>
      <guid>https://depp.wang/2025/claude-code/</guid>
      <pubDate>Tue, 12 Aug 2025 14:29:17 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/20250812222738.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;AI-编程工具的进化之路&quot;&gt;&lt;a href=&quot;#AI-编程工具的进化之路&quot; class=&quot;headerlink&quot; title=&quot;AI 编程工具的进化之路&quot;&gt;&lt;/a&gt;AI 编程工具的进化之路&lt;/h2&gt;&lt;p&gt;过去几年，AI 编程工具经历了一场革命性的演变：从 GitHub Copilot 到 ChatGPT，再到 Cursor，最后到现在的 Claude Code。每一次迭代都在解决前一代工具的痛点。  &lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/20250812222738.png" alt=""></p><h2 id="AI-编程工具的进化之路"><a href="#AI-编程工具的进化之路" class="headerlink" title="AI 编程工具的进化之路"></a>AI 编程工具的进化之路</h2><p>过去几年，AI 编程工具经历了一场革命性的演变：从 GitHub Copilot 到 ChatGPT，再到 Cursor，最后到现在的 Claude Code。每一次迭代都在解决前一代工具的痛点。  </p><a id="more"></a><p><strong>Copilot 时代</strong>：开启了 AI 自动补全的先河，让编程不再是纯粹的体力活。但它只能做简单的代码续写，像是给你配了一个只会接话茬的助手。  </p><p><strong>ChatGPT 时代</strong>：终于可以理解复杂需求了，但每次都要手动复制粘贴代码，来回切换窗口。就像请了个高手给你写代码，但他只能隔着玻璃窗给你递纸条。  </p><p><strong>Cursor 时代</strong>：解决了复制粘贴的问题，直接在编辑器里对话和修改。但它把你锁在了 VSCode 生态里，用 JETBRAINS IDEs  的开发者只能干瞪眼。  </p><p><strong>Claude Code 时代</strong>：这是真正的游戏规则改变者。它理解的不仅是代码片段，而是整个项目的上下文。更重要的是，它能与任何编辑器协同工作，无论你是 IDEA 的死忠粉还是 Vim 的极客。  </p><h2 id="上下文工程的威力"><a href="#上下文工程的威力" class="headerlink" title="上下文工程的威力"></a>上下文工程的威力</h2><p>传统的提示词工程就像在黑暗中摸索，你得不断猜测 AI 需要什么信息。而上下文工程则完全不同——它让 AI 一开始就拥有项目的全貌。（ps：Claude 4 Opus 上下文容量 200K tokens）  </p><p>想象一下，传统提示词就像给新员工一句话的任务说明，然后期待他完成整个项目。而上下文工程则是给他完整的项目文档、代码规范、历史决策记录，让他从第一天就像老员工一样工作。  </p><p>Claude Code 在这方面做得尤其出色。它能自动理解项目结构、读取配置文件、分析代码风格，甚至能理解你的 git 历史。这不是简单的”智能补全”，而是真正的”智能协作”。  </p><h2 id="Claude-Code-的优势"><a href="#Claude-Code-的优势" class="headerlink" title="Claude Code 的优势"></a>Claude Code 的优势</h2><h3 id="对比-Cursor"><a href="#对比-Cursor" class="headerlink" title="对比 Cursor"></a>对比 Cursor</h3><p>Cursor 确实很强，但它把你绑定在 VSCode 上。而 Claude Code 可以与任何编辑器配合使用。我经常在 IDEA 里写 Java，在 VSCode 里写前端，Claude Code 都能无缝衔接。它不是要取代你的编辑器，而是成为你的编程伙伴。  </p><h3 id="对比-Augment-Code"><a href="#对比-Augment-Code" class="headerlink" title="对比 Augment Code"></a>对比 Augment Code</h3><p><a href="https://www.augmentcode.com/" target="_blank" rel="noopener">Augment Code</a> 在速度上略胜一筹，但 Augment Code 只是作为集成环境的一个插件，不像 Claude Code，有自己的终端，使用场景更多，Claude Code 还可以在 GitHub 上直接使用。 </p><h3 id="对比-Codex-CLI（2025-10-30）"><a href="#对比-Codex-CLI（2025-10-30）" class="headerlink" title="对比 Codex CLI（2025-10-30）"></a>对比 Codex CLI（2025-10-30）</h3><ul><li>优势：上下文基于项目（适合长期使用），Codex 是基于 Session（适合临时使用）。权限管理好一些，有子代理，斜杠命令功能。</li><li>劣势：同样的 20 美元的套餐，都使用最好的模型，Codex 更耐用一点，Claude Code 很快就触发了 5 小时限额。</li></ul><h2 id="国内用户购买指南"><a href="#国内用户购买指南" class="headerlink" title="国内用户购买指南"></a>国内用户购买指南</h2><h3 id="购买方式"><a href="#购买方式" class="headerlink" title="购买方式"></a>购买方式</h3><p>最简单的方式是通过美区 Apple 账号购买。先用礼品卡充值 Apple 账号余额，然后订阅。这样既安全又方便，还能避免信用卡直接扣费的风险。  </p><h3 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h3><p>我买的是 Max  - 124.99 美元版本（24.99 的 Apple 手续费），约 900 元/月，使用至今基本没有触发过限额。相比之下，API 按 token 计费让人提心吊胆，总担心一不小心耗费太多 money。Max 版本让你可以放心大胆地用，只心疼一次，然后就是纯享受了。  </p><h3 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h3><p>建议使用固定 IP，保持稳定的使用环境。我使用固定 IP，一直正常使用，没有遇到任何风控问题。  </p><h3 id="统计用量"><a href="#统计用量" class="headerlink" title="统计用量"></a>统计用量</h3><p>使用 <code>/logout</code> 命令可以查看详细的 token 使用统计，了解自己的使用频率和习惯，判断是否物超所值。  </p><h2 id="实战技巧：让-Claude-Code-成为你的超级助手"><a href="#实战技巧：让-Claude-Code-成为你的超级助手" class="headerlink" title="实战技巧：让 Claude Code 成为你的超级助手"></a>实战技巧：让 Claude Code 成为你的超级助手</h2><h3 id="完整的需求链路"><a href="#完整的需求链路" class="headerlink" title="完整的需求链路"></a>完整的需求链路</h3><p>不要只丢给它一个模糊的需求。我的工作流程是这样的：  </p><ol><li><strong>给它需求文档</strong> → 让它理解业务背景  </li><li><strong>生成技术方案</strong> → 包括接口设计、数据库结构等  </li><li><strong>生成测试场景文档</strong> → 定义清楚的验收标准  </li><li><strong>代码生成</strong> → 基于上述所有上下文生成代码  </li></ol><p>这样生成的代码不仅能跑，还符合业务逻辑，甚至包含了边界处理和异常情况。  </p><h3 id="一次性给足信息"><a href="#一次性给足信息" class="headerlink" title="一次性给足信息"></a>一次性给足信息</h3><p>最好一次性把所有需求、约束、边界条件都说清楚。Claude Code 在拥有完整上下文时表现最佳。分段式的需求会导致它不断修改之前的代码，效率反而更低。  </p><h3 id="常见问题与解决"><a href="#常见问题与解决" class="headerlink" title="常见问题与解决"></a>常见问题与解决</h3><ol><li><strong>功能可以实现，但不是最优解</strong>：这时候可以明确告诉它性能要求或者提供参考实现  </li><li><strong>代码可读性问题</strong>：可以要求它遵循特定的代码规范，或者提供项目中的代码示例作为参考  </li></ol><h3 id="让-AI-做脏活累活"><a href="#让-AI-做脏活累活" class="headerlink" title="让 AI 做脏活累活"></a>让 AI 做脏活累活</h3><p>单元测试、接口文档、数据 Mock、代码重构——这些重要但枯燥的工作，都可以交给 Claude Code。它不会抱怨，不会偷懒，而且比人工更细致。  </p><h2 id="总结：AI-时代的编程新范式"><a href="#总结：AI-时代的编程新范式" class="headerlink" title="总结：AI 时代的编程新范式"></a>总结：AI 时代的编程新范式</h2><p>800 多块一个月，说贵也贵，说值也值。为了用回本，我发现自己写代码越来越多了。以前懒得做的个人项目，现在都能快速实现。在不熟悉的技术栈上，不用再从零开始摸索。  </p><p>但要记住一点：<strong>AI 不会让你变成超人</strong>。如果你 hold 不住生成的代码，那它就只是一个昂贵的玩具。Claude Code 是工具，不是魔法。它能让优秀的程序员更高效，但不能让不懂编程的人变成架构师。  </p><p>最后，这个时代的程序员是幸运的。我们有了真正的「编程伙伴」，可以把精力放在更有创造性的工作上。脏活累活交给 AI，创新和决策留给自己——这才是人机协作的正确打开方式。  </p><p>当然，每个月看到扣款通知时，心还是会痛一下的。但想想节省的时间和提升的效率，这大概是我在自己身上做过的最值得的投资了。</p>]]></content:encoded>
      
      <comments>https://depp.wang/2025/claude-code/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Apple Watch 选购经验和使用体验</title>
      <link>https://depp.wang/2025/apple-watch/</link>
      <guid>https://depp.wang/2025/apple-watch/</guid>
      <pubDate>Mon, 04 Aug 2025 16:29:49 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/apple-watch-series-9.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;去年双十一入手了 Apple Watch S9 蜂窝版。使用了大半年后，分享一下选购经验和使用体验，希望能帮到正在纠结的朋友。&lt;/p&gt;
&lt;p&gt;我买 Apple Watch 主要有 2 个目的：运动记录，苹果生态完善。我买的 S9 蜂窝版，S9 是 23 年发布的，现在应该没有生产了，全新未拆封版本应该越到后面越不好买了。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/apple-watch-series-9.png" alt=""></p><p>去年双十一入手了 Apple Watch S9 蜂窝版。使用了大半年后，分享一下选购经验和使用体验，希望能帮到正在纠结的朋友。</p><p>我买 Apple Watch 主要有 2 个目的：运动记录，苹果生态完善。我买的 S9 蜂窝版，S9 是 23 年发布的，现在应该没有生产了，全新未拆封版本应该越到后面越不好买了。</p><a id="more"></a><h2 id="版本对比"><a href="#版本对比" class="headerlink" title="版本对比"></a>版本对比</h2><p>为什么选择 Apple Watch S9 蜂窝版</p><h3 id="蜂窝版-VS-GPS-版"><a href="#蜂窝版-VS-GPS-版" class="headerlink" title="蜂窝版 VS GPS 版"></a>蜂窝版 VS GPS 版</h3><p>蜂窝版比较常见的问题：</p><ol><li>有必要选择蜂窝版吗</li><li>蜂窝版会比 GPS 版本的续航更差吗</li><li>蜂窝版手机关机后也可以使用吗</li></ol><p>我的实测经验：</p><ol><li>蜂窝版的优势是可以独立手机使用，有 eSIM 卡，不带手机也能接打电话和联网使用网络。eSIM 一般每月额外需要 10 元费用，看你个人需要</li><li>开启蜂窝功能后，续航和 GPS 版差别不大（后面有详细测试数据）</li><li>可以，只是利用手机将 eSIM 写 Watch，Watch 中有了 eSIM 信息，eSIM 功能就不需要手机了</li></ol><p>我选择了蜂窝版，主要因为其可以独立使用。</p><h4 id="eSIM-不能保号"><a href="#eSIM-不能保号" class="headerlink" title="eSIM 不能保号"></a>eSIM 不能保号</h4><p>我原来打算买日版 iPhone，日版 iPhone 手机是单卡的，自己又需要 2 张卡，想手机插一张卡，Apple Watch 利用 eSIM 使用一张卡，但发现不行。</p><p>经我测试，蜂窝版 Watch 利用 eSIM 开通一号双终端后，可以独立 iPhone 使用手机卡功能，即使手机关机或者对应实体卡不插上 iPhone 上也可以使用。</p><p>但当 iPhone 连接配合使用时，其本身的手机卡功能不可用，我猜测这个原因是因为即使没有蜂窝功能的 GPS Watch，在连接 iPhone 时，本身也可以唤起与接打 iPhone 上的电话。所以当蜂窝版 Watch 连接手机后，蜂窝版 Watch 优先满足 iPhone 的通信功能，除非 Watch 的号码也在 iPhone。</p><p>最后的解决方案：买个双卡手机，用其中一个流量卡开通 eSIM。</p><h3 id="SE-VS-S9"><a href="#SE-VS-S9" class="headerlink" title="SE VS S9"></a>SE VS S9</h3><p>SE 便宜不少，但 S9 有几个优势：</p><ol><li>颜值更高：屏幕体验更好，更亮、更大、全天候显示</li><li>健康监测更全：血氧、移动心电图、体温检测、心律不齐提醒、估算排卵日等</li><li>有手势操作：捏合手指就能操作。PS：实际基本没有怎么使用</li></ol><p>手表还有一定的装饰作用，主要因为颜值，选了功能更全的 S9。</p><h3 id="S9-VS-S10"><a href="#S9-VS-S10" class="headerlink" title="S9 VS S10"></a>S9 VS S10</h3><p>S10 是最新款，相比 S9 的有一些优势：</p><ul><li>更薄更轻</li><li>支持音乐外放</li><li>可视角度更好</li><li>支持水温和深度检测</li><li>可以显示秒表</li></ul><p>但有一个巨大的劣势，就是国行版本阉割了快充功能，S10 要 1 个半小时才能充满电。S10 可能需要晚上专门充电，导致晚上不能睡眠监测。S9 有快充（从 0% 充到 80% 约需 45 分钟），早晚洗漱时充电一下即可。</p><p>S9 充电速度更快，价格还更实惠。推荐选 S9。</p><h3 id="国行-VS-港版"><a href="#国行-VS-港版" class="headerlink" title="国行 VS 港版"></a>国行 VS 港版</h3><p>功能差异主要是港版多了「睡眠呼吸暂停通知」功能。不过看 V2EX 上说国行也能通过一些方法开启，所以最后买了国行。虽然买了很久了，但也没有折腾开启这个功能。</p><h2 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h2><p>默认 Apple Watch 需要一台装有 iOS 18 以上的 iPhone 才能激活，有一些方法可以让低版本 iOS 也可以激活 Apple Watch，可以在 BiliBili 上搜索教程。</p><h3 id="续航测试"><a href="#续航测试" class="headerlink" title="续航测试"></a>续航测试</h3><p>这是大家最关心的问题，我详细记录了几种使用场景。</p><p>日常使用（蜂窝数据开启，连接 iPhone）：</p><ul><li>白天 12 小时耗电约 70%（初始设置）</li><li>关闭噪音检测、Siri 抬腕唤醒、大部分通知后：耗电约 48-50%</li><li>晚上睡眠 10 小时耗电约 26%</li><li>运动 1 小时会额外耗电 10-15%</li></ul><p>实际测试数据（关闭不必要功能后）：</p><ul><li>2024/11/18：白天 13.5 小时耗电 56%（无运动）</li><li>2024/11/19：白天 11.5 小时耗电 46%（无运动）</li></ul><p>总的来说，不管运动与否，只要早晚洗漱时充电到 80% 以上，下次充电前都不会低于 20%。PS：打电话非常耗电</p><h3 id="实用功能"><a href="#实用功能" class="headerlink" title="实用功能"></a>实用功能</h3><p>使用大半年后，这些功能比较常用与实用：</p><ol><li>运动记录：支持打羽毛球/游泳（防水功能默认开启）/徒步/跳绳几十种运动记录</li><li>睡眠监测：可以监控睡眠/深睡时长、心率、呼吸频率，但感觉时长数据不是特别准</li><li>活动圆环：可统计每天消耗能量/运动时长与站立小时</li><li>提醒事项：同步 iPhone 的待办事项，手腕上就能查看和勾选</li><li>定时器：厨房定时，午睡闹钟</li><li>起床闹钟：震动叫醒，不吵到家人</li><li>手电筒：晚上起夜不用摸手机</li><li>翻译：数据可以同步到手机</li><li>站立提醒：久坐党的福音</li><li>手表接电话：做饭、运动时特别方便，手机不在旁边也能接</li><li>语音备忘录：录音/快速记录想法和灵感</li><li>找手机：手机不知道放哪了，手表一键就能找到</li><li>心率监测：运动时实时查看心率，还有 HRV（心率变异性）分析</li><li>摔倒检测：给家里老人买的话这个功能很重要</li><li>心电图：移动心电图功能，可以检测房颤等</li><li>经期监测：女性用户的贴心功能</li><li>相机：手表控制手机拍照/录像</li></ol><h3 id="软件推荐"><a href="#软件推荐" class="headerlink" title="软件推荐"></a>软件推荐</h3><p>除了系统自带功能，这些第三方 App 也很实用：</p><ol><li>两步路：手表运动轨迹，节约手机电量</li><li>西窗烛：诗词阅读，碎片时间学习古诗词</li><li>每日英语听力：练习听力，支持后台播放</li><li>Daylight Goals：可以直接查看手机隐藏的日照时间功能</li><li>Qweather：天气预报，数据挺准</li><li>GrowPal：查看 HRV，我没买会员</li></ol><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>使用过程中也发现一些不足：</p><ol><li>声音不能外放，需要连接蓝牙设备（S9 不支持，S10 支持）</li><li>付款码无法针对个人付款，只能针对商家付款码</li><li>限制了长文字，像 Notes，Books 都不能用，只能用语音备忘录。这个倒能理解，手表戴着，手长时间放眼睛面前，手很累</li><li>没有浏览器 APP，Siri 不太好用</li><li>没有一个好用的词典 APP</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Apple Watch S9 蜂窝版做一个记录运动的辅助设备，偶尔运动出门可以不带手机。但还是无法当做主力设备使用：1、没有摄像头，不能扫码登录/拍照；2、不支持个人付款；3、电池小，续航短。</p><p>只把 Watch 当成一个辅助设备，使用大半年下来，整体体验还是比较满意。如果你也是 Apple 生态用户，有以下需求的话值得入手：</p><ul><li>喜欢运动，想要记录运动</li><li>对健康监测功能有需求</li></ul><p>如果只是想尝鲜或者预算有限，SE / GPS 版也是不错的选择。根据自己的实际需求选择就好。Android 用户使用的话，激活需要 iPhone，有些跟 iPhone 关联的功能都用不了，如相机/相册，手机端查看更详细的数据。如果要买，更推荐买蜂窝版，可以独立连网。</p><h2 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h2><ul><li><a href="https://www.bilibili.com/video/BV1ur421L7xv/" target="_blank" rel="noopener">Apple Watch 蜂窝版使用体验，续航测试及对比 GPS 版！- BiliBili</a></li><li><a href="https://www.v2ex.com/t/1075937" target="_blank" rel="noopener">在国行 Apple Watch 开通睡眠呼吸暂停通知 - V2EX</a></li><li><a href="https://support.apple.com/zh-cn/guide/watch/apd4ad3571d9/11.0/watchos/11.0" target="_blank" rel="noopener">取消配对并抹掉 Apple Watch - Apple 支持</a></li></ul>]]></content:encoded>
      
      <comments>https://depp.wang/2025/apple-watch/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ProNotes，让 Apple Notes 支持 MarkDown</title>
      <link>https://depp.wang/2025/pro-notes/</link>
      <guid>https://depp.wang/2025/pro-notes/</guid>
      <pubDate>Tue, 20 May 2025 13:01:26 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;https://assets.pronotes.app/videos/pronotes-bar.mp4&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我一直使用 &lt;a href=&quot;https://depp.wang/2024/my-obsidian-experience/&quot;&gt;Obsidian 作为我的笔记工具&lt;/a&gt;，虽然一直用 Apple 全家桶，但却基本不使用 Apple Notes，原因是因为它不支持 MarkDown。虽然不少人将 Apple Notes 称作是最好的笔记工具，但对我来说，支持 MarkDown 的 Obsidian 更适合我。 Obsidian 虽好，但手机端编辑还是稍微有点麻烦，没有 Apple Notes 那么方便。Obsidian 通过 GitHub 实现的同步也没有 Apple Cloud 那么无感。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/20250520212532.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://assets.pronotes.app/videos/pronotes-bar.mp4" alt=""></p><p>我一直使用 <a href="https://depp.wang/2024/my-obsidian-experience/">Obsidian 作为我的笔记工具</a>，虽然一直用 Apple 全家桶，但却基本不使用 Apple Notes，原因是因为它不支持 MarkDown。虽然不少人将 Apple Notes 称作是最好的笔记工具，但对我来说，支持 MarkDown 的 Obsidian 更适合我。 Obsidian 虽好，但手机端编辑还是稍微有点麻烦，没有 Apple Notes 那么方便。Obsidian 通过 GitHub 实现的同步也没有 Apple Cloud 那么无感。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/20250520212532.png" alt=""></p><a id="more"></a><p>最近了解到了可以在 macOS 13.0+ 上让 Apple Notes 支持 MarkDown 的神器 - <a href="https://www.pronotes.app/" target="_blank" rel="noopener">ProNotes</a>。具体的功能我就不多做介绍了，可以直接看官网教程，或者 BiliBili 搜索视频教程。ProNotes 还有一个我很喜欢的功能，就是支持笔记双向链接（Link），这功能也是 Obsidian 的核心功能之一，使笔记间能互相索引。加上 Apple Notes 本身也支持的标签功能，可以说让 Apple Notes 具有了 Obsidian 最重要的 2 个核心功能。ProNotes 作者也很良心，目前核心功能全免费，只有附加的 AI 功能收费。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/20250520213014.png" alt=""></p><p>Apple Notes 有了 ProNotes，确实使 Apple Notes 有了质的提升，但我还不太适应 macOS 端 Apple Notes 编辑界面，觉得还是没有我 Obsidian 自定义的页面美观。另外就是虽然 ProNotes 可以复制 Apple Notes 内容为 MarkDown，但还是无法直接复制图片到 Obsidian / Typora 这类编辑器中，只能单独挨个复制图片。如果是直接复制通过剪贴板粘贴的图片，复制的图片会存在文件格式的问题而无法显示。我测试发现 Typora 可以直接复制 MarkDown 内容（包含图片内容）到 Notes，Obsidian 不行。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/20250520212957.png" alt=""></p><p>目前我尝试使用 Apple Notes 来作为我的主要笔记工具，看看效果怎么样。Obsidian 也还是会继续使用，毕竟像自动发布博客这种功能 Apple Notes 也做不到。</p>]]></content:encoded>
      
      <comments>https://depp.wang/2025/pro-notes/#disqus_thread</comments>
    </item>
    
    <item>
      <title>充电宝的额定容量与充电次数</title>
      <link>https://depp.wang/2025/rechargeable-battery/</link>
      <guid>https://depp.wang/2025/rechargeable-battery/</guid>
      <pubDate>Sun, 05 Jan 2025 11:59:51 GMT</pubDate>
      <description>
      
        &lt;p&gt;买了个酷态科（原 ZMI）的&lt;a href=&quot;https://union-click.jd.com/jdc?e=618%7Cpc%7C&amp;p=JF8BASUJK1olXDYCVV9dC0oUBmsKH1klGVlaCgFtUQ5SQi0DBUVNGFJeSwUIFxlJX3EIGloVXgcBUVpfDEkIWipURmt9WFZFKScLSyhEdWx2ThoQNAdAFlstBEcnAl8LGlgUXgUEVVZcOHsXBF9edVsUXAcHUFtUC00nAl8IHVkRVQ4BUldUAEMTM2gIEmtOCGgEBAoOCxgWCzpdHlsWbTYyV25aCEIDBR1JSU8TLzYyVG5eOEsWA2cLG1sUWgUKSF5fAE8fBHMIHVkRVQ4BUlddCEMVM20JGl8cbTbc2e4tfQoTZRtrRFtOKHxSMAYE1sanEgRxE1sVXhcyPSc6ABxrfQQMYV9tOllKPBY2ARNtC2hxdVlsJkQFUVdUTk9KVBlKQC93OTYHZA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;立式无线充电宝&lt;/a&gt;，商品介绍写的「电池能量 10000mAh，额定容量 5800mAh，iPhone 16 完整充满 1.8 次」。出现了 2 个数值，并且 iPhone 16 的电池容量是 3355mAh，两个数值除以 3355mAh 也不等于 1.8。比较好奇为什么这样，我查了点资料，以下是我了解的原因。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;2 个数值&lt;/th&gt;
&lt;th&gt;1.8 次&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;https://hexoblog.r2.xingquan.wang/202501041735998848.png&quot; alt=&quot;&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://hexoblog.r2.xingquan.wang/202501041735998951.png&quot; alt=&quot;&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>买了个酷态科（原 ZMI）的<a href="https://union-click.jd.com/jdc?e=618%7Cpc%7C&p=JF8BASUJK1olXDYCVV9dC0oUBmsKH1klGVlaCgFtUQ5SQi0DBUVNGFJeSwUIFxlJX3EIGloVXgcBUVpfDEkIWipURmt9WFZFKScLSyhEdWx2ThoQNAdAFlstBEcnAl8LGlgUXgUEVVZcOHsXBF9edVsUXAcHUFtUC00nAl8IHVkRVQ4BUldUAEMTM2gIEmtOCGgEBAoOCxgWCzpdHlsWbTYyV25aCEIDBR1JSU8TLzYyVG5eOEsWA2cLG1sUWgUKSF5fAE8fBHMIHVkRVQ4BUlddCEMVM20JGl8cbTbc2e4tfQoTZRtrRFtOKHxSMAYE1sanEgRxE1sVXhcyPSc6ABxrfQQMYV9tOllKPBY2ARNtC2hxdVlsJkQFUVdUTk9KVBlKQC93OTYHZA" target="_blank" rel="noopener">立式无线充电宝</a>，商品介绍写的「电池能量 10000mAh，额定容量 5800mAh，iPhone 16 完整充满 1.8 次」。出现了 2 个数值，并且 iPhone 16 的电池容量是 3355mAh，两个数值除以 3355mAh 也不等于 1.8。比较好奇为什么这样，我查了点资料，以下是我了解的原因。</p><table><thead><tr><th>2 个数值</th><th>1.8 次</th></tr></thead><tbody><tr><td><img src="https://hexoblog.r2.xingquan.wang/202501041735998848.png" alt=""></td><td><img src="https://hexoblog.r2.xingquan.wang/202501041735998951.png" alt=""></td></tr></tbody></table><a id="more"></a><h2 id="1、为什么电池能量是-10000mAh，额定容量是-5800mAh"><a href="#1、为什么电池能量是-10000mAh，额定容量是-5800mAh" class="headerlink" title="1、为什么电池能量是 10000mAh，额定容量是 5800mAh"></a>1、为什么电池能量是 10000mAh，额定容量是 5800mAh</h2><p>电池能量是电池以内部电压 3.65V 存储的能量，额定容量是按 5V 标准输出的容量。这 2 个单位是毫安 mAh，但毫安不是能量单位，这 2 个数值都需要转为能量单位 Wh 来看。</p><p>这个充电宝内部电压是 3.65V，代表充电宝是以 3.65V 电压存储的能量，存储能量是 10000mAh * 3.65 = 36.5Wh。而实际充电时，是以 5V 输出的，会升压，升压过程会发生发热等能量损失，可输出能量是额定容量 5800mAh * 5V = 29Wh。根据能量守恒定律，能量不会消失，只是部分转化为其它能量（比如热能）。相当于升压过程损失了 7.5Wh，也符合说明书里面写的是「电源转换效率：79%」。其实这个充电宝，应该标明其可输出的真实能量是 29Wh，但应该出于行业做法与宣传目的，没有写上这个数值。</p><p><img src="https://hexoblog.r2.xingquan.wang/202501041736002986.png" alt=""></p><h2 id="2、为什么-10000mAh-iPhone-16-完整充满-1-8-次"><a href="#2、为什么-10000mAh-iPhone-16-完整充满-1-8-次" class="headerlink" title="2、为什么 10000mAh iPhone 16 完整充满 1.8 次"></a>2、为什么 10000mAh iPhone 16 完整充满 1.8 次</h2><p>我也问了一下商品客服，客服说是实验室参数。我查了一下，iPhone 16 的电池容量 3355 mAh，内部电压 3.88V，电池容量 13Wh。</p><p><img src="https://hexoblog.r2.xingquan.wang/202501041736003784.png" alt=""></p><p>充电宝可输出的能量是 29Wh，电池能量是 13Wh，那应该可以充电 2.23 次。(13 * 1.8) / 29 ≈ 80.6%，因为充电过程中也会有手机、充电器发热等能量损失，所以充电能量转换率在 80.6% 左右。</p><h2 id="3、充电宝最高可输出-20W，不同输出功率，是否影响充电次数"><a href="#3、充电宝最高可输出-20W，不同输出功率，是否影响充电次数" class="headerlink" title="3、充电宝最高可输出 20W，不同输出功率，是否影响充电次数"></a>3、充电宝最高可输出 20W，不同输出功率，是否影响充电次数</h2><p>充电宝最高可输出 9V * 2.22A = 20W 功率给手机充电，如果充电功率越高，充电次数应该是达不到 1.8 次的，1.8 次只是以 5V 输出的理想数值。</p><p>因为升压越多，充电宝转换损失能量也就越多。手机将输入转存储损失应该也会变多，充电次数应该会减少。</p><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><ul><li><a href="https://www.bilibili.com/video/BV1Hg4y1o7RH" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Hg4y1o7RH</a></li></ul>]]></content:encoded>
      
      <comments>https://depp.wang/2025/rechargeable-battery/#disqus_thread</comments>
    </item>
    
    <item>
      <title>我为什么没有为了 AI 功能买外版 iPhone</title>
      <link>https://depp.wang/2024/ai-iphone/</link>
      <guid>https://depp.wang/2024/ai-iphone/</guid>
      <pubDate>Sat, 21 Dec 2024 10:27:27 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;a href=&quot;https://www.apple.com/apple-intelligence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;苹果智能（Apple Intelligence）&lt;/a&gt; 是苹果推出的一项人工智能技术，可以在 iPhone / Mac 等各设备上通过 AI 功能辅助提升用户体验。是苹果公司在近年新设备硬件升级不大的情况下，想通过软件的方式进一步提升新设备销量的手段。AI 限制了只有 8G 及以上运行内存的手机（iPhone 15 Pro / iPhone 15 Pro Max 及最新机型）才能使用。&lt;/p&gt;
&lt;p&gt;苹果这次对 AI 使用了&lt;a href=&quot;https://hexoblog.r2.xingquan.wang/202409131726190471.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;硬件锁&lt;/a&gt;，国行即使换区换网络也不能使用国外的 AI 服务提供商，只能使用国内的。国行 iPhone 虽然可以通过一些&lt;a href=&quot;https://www.bilibili.com/video/BV1mS1TYQEwo/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;方式&lt;/a&gt;绕过限制，但也有一定的风险。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="https://www.apple.com/apple-intelligence/" target="_blank" rel="noopener">苹果智能（Apple Intelligence）</a> 是苹果推出的一项人工智能技术，可以在 iPhone / Mac 等各设备上通过 AI 功能辅助提升用户体验。是苹果公司在近年新设备硬件升级不大的情况下，想通过软件的方式进一步提升新设备销量的手段。AI 限制了只有 8G 及以上运行内存的手机（iPhone 15 Pro / iPhone 15 Pro Max 及最新机型）才能使用。</p><p>苹果这次对 AI 使用了<a href="https://hexoblog.r2.xingquan.wang/202409131726190471.png" target="_blank" rel="noopener">硬件锁</a>，国行即使换区换网络也不能使用国外的 AI 服务提供商，只能使用国内的。国行 iPhone 虽然可以通过一些<a href="https://www.bilibili.com/video/BV1mS1TYQEwo/" target="_blank" rel="noopener">方式</a>绕过限制，但也有一定的风险。</p><a id="more"></a><p>我上一个手机 iPhone XR 已经使用 5 年了，也到了换手机的时机了，我最终决定换 iPhone 15 Pro（主要因为重量和长焦） 。因为苹果 AI 只能使用国内 AI 服务提供商（传言还是百度）的原因，最开始是想着换一部日版 iPhone 的。另外我作为一位软件开发者，也想折腾下。再加上外版 iPhone 还有一些国行 iPhone 被阉割的功能。</p><p>花了点时间做了一下功课，我最终没有买外版 iPhone，以下是一些原因。</p><p><strong>首先，我有双卡需求。</strong> 这是最主要的原因。我使用一张电话卡 + 一张流量卡。电话卡绑定了各个银行与各种服务，更换很麻烦。而我的流量卡又就是宽带，也不能换。我想尝试使用 Apple Watch 来绑定一张卡，手机插一张卡，<a href="https://x.com/deppwang1/status/1870440615550632273" target="_blank" rel="noopener">发现不行</a>。虽然可以购买港版 iPhone，港版 iPhone 有双实体卡 + eSIM，但我在重庆，港版 iPhone 15 Pro 货源太少，其它渠道购买有一定风险，也就没有考虑。</p><p><strong>其次，我觉得手机 AI 功能没有那么重要</strong>。手机的 AI 功能很早就是一个宣传的卖点，但原来的作用很有限，也比较鸡肋。在大模型出现后，现在的手机 AI 可能更好用，但手机对大多数人来说，不是生产力工具，手机的 AI 功能，我觉得没有太大的用处。另外，虽然在系统级别上限制了不能使用国外 AI，但国内 AI 虽然比不上国外 AI，但一半的能力应该也还是有的，等明年中文 AI 上线了，还是可以体验下的。</p><p><strong>第三，外版 iPhone 的价格更贵了</strong>。以前的全新外版 iPhone 因为汇率等关系，相比国行，更有价格优势。而现在，购买全新外版 iPhone 比国行更贵了。对于我来说，用手机做的事情本来也不多，本来也需要少玩手机，太贵就没有必要了。毕竟也只是一个手机而已，也不是生产力工具。而在二手市场，相比大量的国行二手，不踩坑的买到合适的二手外版 iPhone 还是需要不少经验才行。</p><p><strong>第四，外版 iPhone 没有<a href="https://www.youtube.com/watch?v=451AtwVcFew" target="_blank" rel="noopener">阉割的功能</a>在国内基本用不上。</strong>外版有而国行没有的功能大概有这些：eSIM/Facetime Audio/海拔/CallKit/Wi‑Fi calling/卫星通讯/Apple News+，除 Facetime Audio ，其它功能如果你在国内也用不了，只有在国外才能用，Facetime Audio 也需要对方也是外版 iPhone 才行。卫星通讯需要在美国才能用。而国行 iPhone 有个外版 iPhone 没有，却有点用的功能，就是可以针对每个 APP 设置「蜂窝与 WIFI」开启与关闭功能。</p><p>以上就是我没有买外版 iPhone 的原因，我觉得外版 iPhone 还是更适合留学生或经常出国的人，不管是 eSIM，还是 Facetime Audio，都是必备功能。对于有真正购买外版 iPhone 需求的朋友，我在准备买外版 iPhone 的过程中，我也在 V2EX 了解到了 2 个的淘宝店可以购买日版 iPhone（东尼乐园/六本木数码），因为我也没买，请自行判断。</p><p>我最终在闲鱼淘了台国行二手 iPhone 15 Pro，成色还不错。在闲鱼买 iPhone 也得出点经验，遇到低价合适的要先拍下，不然容易被截胡。</p>]]></content:encoded>
      
      <comments>https://depp.wang/2024/ai-iphone/#disqus_thread</comments>
    </item>
    
    <item>
      <title>我如何使用 Obsidian 管理我的个人知识库</title>
      <link>https://depp.wang/2024/my-obsidian-experience/</link>
      <guid>https://depp.wang/2024/my-obsidian-experience/</guid>
      <pubDate>Mon, 24 Jun 2024 14:30:07 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;https://hexoblog.r2.depp.wang/202406241719240323.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我使用 &lt;a href=&quot;https://obsidian.md/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Obsidian&lt;/a&gt; 管理我的个人知识库，选择它的主要原因是因为自己的数据可以掌握在自己手上，另外它支持使用标签、双链（双向链接），搜索也很准确。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://hexoblog.r2.depp.wang/202406241719240323.png" alt=""></p><p>我使用 <a href="https://obsidian.md/" target="_blank" rel="noopener">Obsidian</a> 管理我的个人知识库，选择它的主要原因是因为自己的数据可以掌握在自己手上，另外它支持使用标签、双链（双向链接），搜索也很准确。</p><a id="more"></a><p>我最开始是使用有道云笔记，用了很多年，后面转而使用数据本地保存、所见即所得的 Typora，为了转移笔记，还写了个<a href="https://github.com/DeppWang/youdaonote-pull" target="_blank" rel="noopener">导出有道云笔记的脚本</a>。后面接触到了 Obsidian，因为标签与双链功能，主力就使用 Obsidian 了。Notion 也是一款比较火的笔记工具，也有标签与双链功能，但因为数据不能掌握在自己手中，就没有考虑使用。</p><p>我用的 Obsidian 的版本一直是 <code>0.15.9</code>，没有用最新版，原因是我喜欢只打开一个标签页，这个版本可以只打开一个标签页，而新版不能设置只打开一个标签页，新版特有的画布（Canvas）功能我目前也不用。主题我用的 <a href="https://github.com/whyt-byte/Blue-Topaz_Obsidian-css" target="_blank" rel="noopener">Blue-Topaz</a>，其英文字体我很喜欢。</p><p>目前我所有知识都是通过 Obsidian 管理，文章 / 笔记 / 思考 / 随想等等。我使用标签区分，没有使用文件夹分类。就 Obsidian 这一处知识库，也可以避免重复记录，也方便查找。还不错的收藏文章的笔记也会记到 Obsidian，相比直接放在收藏工具中，想找的时候更容易找到。</p><p>Obsidian 的插件功能，是 Obsidian 相比其它笔记管理工具最大的优势。插件类似 VS Code 的插件，可以额外实现不少功能。以下是我比较常用的、通过插件实现的功能。</p><h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><p>Obsidian 提供同步功能，费用我觉得有点贵，我没有用。我是使用 iCloud 同步，并 GitHub 私有库备份。iCloud 无需手动拉取与推送，比较方便，用于同步。但 iCloud 无法查看历史修改记录，而使用 Git 则可以补充这部分缺陷，GitHub 作一个备份，也不怕 iCloud 同步出问题。我 iOS 手机端使用 1Writer，Obsidian 的 Git 插件我使用的 <a href="https://github.com/denolehov/obsidian-git" target="_blank" rel="noopener">obisidian-git</a>。</p><h2 id="自动发文"><a href="#自动发文" class="headerlink" title="自动发文"></a>自动发文</h2><p>我 <a href="https:/depp.wang" target="_blank" rel="noopener">Blog</a> 使用静态博客框架 Hexo。但我文章创建与编辑是在 Obsidian 中完成的，我写了一个脚本，通过 Github Action 实现文章<a href="https://github.com/DeppWang/obsidian_to_hexoblog" target="_blank" rel="noopener">自动同步到 Hexo</a> 源文件，再触发<a href="https://depp.wang/2020/02/17/use-github-actions-to-achieve-hexo-blog-auto-deploy/">自动发布</a>。</p><h2 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h2><p>图片上传我使用的 PicGo，使用的 <a href="https://github.com/renmu123/obsidian-image-auto-upload-plugin" target="_blank" rel="noopener">obsidian-image-auto-upload-plugin</a> 插件，截图工具我使用的 Xnip，我通过 Automator 配置了一个截图后<a href="https://depp.wang/2020/08/07/how-to-automatically-compress-screenshot-size-in-macos/">自动压缩截图</a>的工作流。</p><h2 id="Obsidian-发推"><a href="#Obsidian-发推" class="headerlink" title="Obsidian 发推"></a>Obsidian 发推</h2><p>我的部分推文也是通过 Obsidian 发送的，借助的 <a href="https://github.com/chhoumann/notetweet_obsidian" target="_blank" rel="noopener">notetweet_obsidian</a> 这个插件，底层使用 Twitter(X) API 实现，Twitter API 目前免费额度只能发布文字，所以无法发送图片等，另外通过这种方式发布的链接也无法识别为卡片。</p><h2 id="自带插件"><a href="#自带插件" class="headerlink" title="自带插件"></a>自带插件</h2><ul><li>自带「快速切换」插件可以实现快速搜索与切换文件，相当于是「Recent Files」</li><li>自带「命令面板」插件可执行快速一些命令，比如打开「标签列表」</li></ul><p>可以看出 Obsidian 的设计思想还是参考了 VS Code 这类代码编辑器的。Obsidian 还有很多功能强大的插件，你可以自行探索一下。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://catcoding.me/p/obsidian-for-programmer/" target="_blank" rel="noopener">我的 Obsidian 使用经验</a></li></ul>]]></content:encoded>
      
      <comments>https://depp.wang/2024/my-obsidian-experience/#disqus_thread</comments>
    </item>
    
    <item>
      <title>《硅谷》- 一部创业踩坑纪录大全</title>
      <link>https://depp.wang/2024/silicon-valley/</link>
      <guid>https://depp.wang/2024/silicon-valley/</guid>
      <pubDate>Sun, 23 Jun 2024 17:13:11 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;https://hexoblog.r2.depp.wang/202406241719160934.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;此文涉及剧透！&lt;/p&gt;
&lt;p&gt;把 HBO 的《硅谷》(Silicon Valley) 看完了，发现《硅谷》就是一部创业踩坑记录大全。&lt;/p&gt;
&lt;p&gt;《硅谷》中「魔笛手」(Pied Piper) 的创业起点在没背景没资源的小公司中算是顶级了，有核心的技术，其压缩算法在硅谷也是最厉害的。创业团队原始成员在各自领域都很擅长，理查德 (Richard) - 算法、吉尔弗约尔 (Gilfoyle) - 硬件 / 架构、迪尼希 (Dinesh) - 软件、「贾里德」(“Jared”) - 财务与运营、巴赫曼 (Bachman) - 营销。创业难，不管什么创业团队，创业过程中都会遇到各种问题，《硅谷》虽然有一定戏剧成分，但确实反应了创业的种种问题。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://hexoblog.r2.depp.wang/202406241719160934.png" alt=""></p><p>此文涉及剧透！</p><p>把 HBO 的《硅谷》(Silicon Valley) 看完了，发现《硅谷》就是一部创业踩坑记录大全。</p><p>《硅谷》中「魔笛手」(Pied Piper) 的创业起点在没背景没资源的小公司中算是顶级了，有核心的技术，其压缩算法在硅谷也是最厉害的。创业团队原始成员在各自领域都很擅长，理查德 (Richard) - 算法、吉尔弗约尔 (Gilfoyle) - 硬件 / 架构、迪尼希 (Dinesh) - 软件、「贾里德」(“Jared”) - 财务与运营、巴赫曼 (Bachman) - 营销。创业难，不管什么创业团队，创业过程中都会遇到各种问题，《硅谷》虽然有一定戏剧成分，但确实反应了创业的种种问题。</p><a id="more"></a><p>「魔笛手」创业过程遇到的问题大概可以分为这几类：技术问题、产品问题、人才问题、管理问题（对人）、运营问题（对事）、财务问题、法律问题、市场竞争问题。我记录了一下各季遇到的问题，并尝试将其区分归类。</p><p>第一季</p><ol><li>被互利（Hooli）完全收购，还是接受彼得（Peter）投资自己创业</li><li>没有人会写企业策划书 - 人才问题</li><li>成员股权怎么分配 - 管理问题</li><li>公司名叫什么 </li><li>公司名被注册</li><li>谁当董事会成员 - 管理问题</li><li>公司 Logo 设计成什么样</li><li>成员重写代码搞出大事故 - 技术问题</li><li>算法被大公司抄袭，没有竞争优势 - 市场竞争问题</li></ol><p>第二季</p><ol start="10"><li>剧中一个公司因为拿过多投资，高估值高期望而达不到被毁掉 </li><li>因为竞争对手的法律纠纷，无风投投资 - 法律问题 / 市场竞争问题</li><li>核心机密因给对方演示给被泄露给竞争对手 - 市场竞争问题<ul><li>竞争对手核心账号密码安全意识也薄弱，被顺走，从而可以进入其后台</li></ul></li><li>没人投资，没有未来，律师费太贵付不起，只能被竞争对手收购  - 财务问题</li><li>CEO 压力太大患病 </li><li>邻居可能举报违法办公场所 - 运营问题</li><li>无理投资人折腾公司 - 管理问题</li><li>误删客户数据（delete 键）</li><li>因为诉讼败诉，差点格式化公司产品 - 法律问题</li><li>CEO 自己被董事会开除  - 管理问题</li></ol><p>第三季</p><ol start="20"><li>和新 CEO 共事，理念不合 - 管理问题</li><li>财务告警，使用了大量资金租办公室  - 财务问题</li><li>不小心泄露对投资人不满情绪给狗仔，导致可能影响自己的 CEO 位置</li><li>存放公司核心机密数据的硬盘丢失 - 运营问题</li><li>竞争对手获取到内部测试版使用权限 - 市场竞争问题</li><li>设计复杂，普通用户不喜欢使用，日活太低 - 产品问题</li><li>因为日活用户不高，用户造假，被发现，风投放弃，被迫卖掉公司 - 运营问题</li></ol><p>第四季</p><ol start="27"><li>原产品失败，新产品不是自己想做的，成员不想转变，自己离开公司 - 产品问题</li><li>魔笛聊没有《服务条款》，违反法律规定，罚款过高</li><li>魔笛聊 CEO（迪尼希）公开场所承认抄袭，法律诉讼问题，公司被免费收购</li><li>没有专利，New Internet 想做但做不了 </li><li>只能和原来的竞争对手合作，却没有合适的员工  - 人才问题</li><li>没人投资，想直接找客户，但没有客户   - 财务问题</li><li>被专利流氓盯上，索要赔款 - 法律问题</li><li>跟客户签订一口价，但客户数据存储暴增，因为云服务费过高，无力支持，面临没有足够的计算资源的问题   - 财务问题 / 运营问题</li><li>如果拿「只做原型，不做产品，只拿投资做估值的忽悠公司」的钱，自己也会被拖下水   - 财务问题</li><li>自己搭建服务器出问题，以为弄丢客户数据 - 运营问题</li></ol><p>第五季</p><ol start="37"><li>招不到合适的员工（盖文抢走了）  - 人才问题</li><li>为了招人，被迫收购远超预计员工数量的公司 - 市场竞争问题</li><li>风投公司无理要求也要接受，比如分点算力给风投投资的其它公司 </li><li>需要风投投资，风投条款规定让你卖广告做营收或者使用用户数据   - 财务问题</li><li>区块链 51% 攻击 - 市场竞争问题</li></ol><p>第六季</p><ol start="42"><li>游戏合作者违规收集与挖掘用户数据，是收入大头，还管不了</li><li>核心人员 COO 「贾里德」离开</li><li>被智利投资人强制收购   - 财务问题<ul><li>用高价卖一部分股票来买一家不让外国人投资的公司</li></ul></li><li>因收购公司 Hooli 的问题被调查影响自己公司 - 法律问题 / 市场竞争问题</li><li>有意向的大客户 AT&amp;T 要跟竞争对手姚网络签约  - 市场竞争问题</li><li>去中心化网络由于技术缺陷，无法扩展规模  - 技术问题</li><li>经过人工智能创造的产品太过厉害，不得不关闭 - 技术问题</li></ol><p>我对可以主观归类的问题分类统计了一下：</p><ul><li>财务问题：7 个</li><li>市场竞争问题：7 个</li><li>管理问题：6 个</li><li>运营问题：5 个</li><li>法律问题：4 个</li><li>人才问题：3 个</li><li>技术问题：3 个</li><li>产品问题：2 个</li></ul><p>发现财务问题和市场竞争问题是「魔笛手」创业过程中最主要的问题，各占了 18% 左右，相比产品和技术问题，合计只占了 13% 左右。当然，这个数据是通过我的个人主观统计计算出来的，不代表是真实的。但在编剧有意的编排下，也有一点参考价值。</p><p>创业在短短几年内可能赚到一辈子打工也赚不到的钱，但成功率确实太低了。只有通过不断创业试错，才有可能成功一次，可普通人根本就没有那么多次机会。现在相比剧集中 2010 年代初期的硅谷，现在的创业成功率也更低了。</p>]]></content:encoded>
      
      <comments>https://depp.wang/2024/silicon-valley/#disqus_thread</comments>
    </item>
    
    <item>
      <title>个人网站图片从阿里云 OSS 迁移到 Cloudflare R2</title>
      <link>https://depp.wang/2024/image-from-oss-to-r2/</link>
      <guid>https://depp.wang/2024/image-from-oss-to-r2/</guid>
      <pubDate>Wed, 19 Jun 2024 11:20:01 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;a href=&quot;https://depp.wang&quot;&gt;个人网站&lt;/a&gt;这两个月访问量增加了不少，导致阿里云对象存储（OSS）费用涨幅很大，1 月 0.09 元、4 月 2.64 元，5 月直接 6.55 元。当初选择阿里云 OSS，就是因为便宜，现在它的这一特性逐渐丧失了。我个人网站部署在 GitHub Pages 上，使用 Cloudflare 做了缓存。因为网站本身就使用了 Cloudflare，加上 Cloudflare R2 的免费额度还能覆盖到目前我的使用量。所以将图片迁移到 Cloudflare R2。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="https://depp.wang">个人网站</a>这两个月访问量增加了不少，导致阿里云对象存储（OSS）费用涨幅很大，1 月 0.09 元、4 月 2.64 元，5 月直接 6.55 元。当初选择阿里云 OSS，就是因为便宜，现在它的这一特性逐渐丧失了。我个人网站部署在 GitHub Pages 上，使用 Cloudflare 做了缓存。因为网站本身就使用了 Cloudflare，加上 Cloudflare R2 的免费额度还能覆盖到目前我的使用量。所以将图片迁移到 Cloudflare R2。</p><a id="more"></a><h2 id="Cloudflare-R2-免费额度与国内访问效果"><a href="#Cloudflare-R2-免费额度与国内访问效果" class="headerlink" title="Cloudflare R2 免费额度与国内访问效果"></a>Cloudflare R2 免费额度与国内访问效果</h2><table><thead><tr><th align="left">免费额度</th><th></th></tr></thead><tbody><tr><td align="left">存储</td><td>10 GB / month</td></tr><tr><td align="left">A 类操作</td><td>每月 100 万个请求</td></tr><tr><td align="left">B 类操作</td><td>每月 1000 万个请求</td></tr><tr><td align="left">出口（数据传输到互联网）</td><td>免费</td></tr></tbody></table><ul><li><a href="https://developers.cloudflare.com/r2/pricing/#free-tier" target="_blank" rel="noopener">https://developers.cloudflare.com/r2/pricing/#free-tier</a></li></ul><p>Cloudflare R2 国内网络访问速度（使用了 Argo Smart Routing）：</p><p><img src="https://hexoblog.r2.depp.wang/202406191718791555.png" alt=""></p><p>阿里云 OSS 国内网络访问效果：</p><p><img src="https://hexoblog.r2.depp.wang/202406191718791581.png" alt=""></p><p>Cloudflare 的访问速度平均只比阿里云的访问速度慢一倍，还可以接受。</p><h2 id="设置-Cloudflare-R2-存储桶可公网访问"><a href="#设置-Cloudflare-R2-存储桶可公网访问" class="headerlink" title="设置 Cloudflare R2 存储桶可公网访问"></a>设置 Cloudflare R2 存储桶可公网访问</h2><p>设置自定义域，如：<code>hexoblog.r2.depp.wang</code></p><p><img src="https://hexoblog.r2.depp.wang/20240618203531.png" alt=""></p><p>设置后可通过: <a href="https://hexoblog.r2.depp.wang/cookie-copy.mp4" target="_blank" rel="noopener">https://hexoblog.r2.depp.wang/cookie-copy.mp4</a> 公网访问 hexoblog 桶中 cookie-copy.mp4</p><h2 id="阿里云-OSS-数据下载"><a href="#阿里云-OSS-数据下载" class="headerlink" title="阿里云 OSS 数据下载"></a>阿里云 OSS 数据下载</h2><p>下载配置命令行工具 ossutil 后，使用命令下载所有数据：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ossutil cp -r oss://deppwang/blog/ /Volumes/NAS/Documents/阿里云对象存储/deppwang/blog-20240618</span><br></pre></td></tr></table></figure><h2 id="数据上传到-Cloudflare-R2"><a href="#数据上传到-Cloudflare-R2" class="headerlink" title="数据上传到 Cloudflare R2"></a>数据上传到 Cloudflare R2</h2><p>Cloudflare R2 使用 AWS S3 存储，macOS 安装 awscli：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install awscli</span><br></pre></td></tr></table></figure><p>Cloudflare R2 中创建 API 令牌，复制「访问密钥 ID (Access Key ID)」、「机密访问密钥 (Secret Access Key)」，使用 <code>aws configure</code> 命令配置，配置后数据在文件 <code>~/.aws/credentials</code> 中。</p><p>配置 endpoint_url</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.aws/config</span><br></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[default]</span></span><br><span class="line"><span class="attr">region</span> = auto</span><br><span class="line"><span class="attr">output</span> = json</span><br><span class="line"><span class="attr">endpoint_url</span> = https://xxx.r2.cloudflarestorage.com</span><br></pre></td></tr></table></figure><p>上传</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 上传单个文件</span></span><br><span class="line">aws s3 cp /Volumes/NAS/备份/阿里云对象存储/deppwang/blog-20240618/cookie-copy.mp4 s3://hexoblog/cookie-copy.mp4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传文件夹</span></span><br><span class="line">aws s3 cp /Volumes/NAS/备份/阿里云对象存储/deppwang/blog-20240618/ s3://hexoblog/ --recursive</span><br></pre></td></tr></table></figure><h2 id="替换指定文件夹中所有文档中的图片链接"><a href="#替换指定文件夹中所有文档中的图片链接" class="headerlink" title="替换指定文件夹中所有文档中的图片链接"></a>替换指定文件夹中所有文档中的图片链接</h2><p>使用脚本实现，以下是我替换我 Obsidian 文件夹的 Python 脚本（ChatGPT 生成）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义旧的和新的图床链接</span></span><br><span class="line">old_link = <span class="string">"https://deppwang.oss-cn-beijing.aliyuncs.com/blog/"</span></span><br><span class="line">new_link = <span class="string">"https://hexoblog.r2.depp.wang/"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Obsidian 文件夹路径</span></span><br><span class="line">obsidian_folder = <span class="string">"/Users/depp/Documents/Obsidian"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式模式</span></span><br><span class="line">pattern1 = re.compile(<span class="string">r'!\[\]\('</span> + re.escape(old_link) + <span class="string">r'([^\)]+)\)'</span>)</span><br><span class="line">pattern2 = re.compile(<span class="string">r'!\[([^\]]*)\]\('</span> + re.escape(old_link) + <span class="string">r'([^\)]+)\)'</span>)</span><br><span class="line">pattern3 = re.compile(<span class="string">r'&lt;img src="'</span> + re.escape(old_link) + <span class="string">r'([^"]+)"'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replace_links</span><span class="params">(file_path)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(file_path, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">        content = file.read()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 替换链接</span></span><br><span class="line">    content = pattern1.sub(<span class="string">r'![]('</span> + new_link + <span class="string">r'\1)'</span>, content)</span><br><span class="line">    content = pattern2.sub(<span class="string">r'![\1]('</span> + new_link + <span class="string">r'\2)'</span>, content)</span><br><span class="line">    content = pattern3.sub(<span class="string">r'&lt;img src="'</span> + new_link + <span class="string">r'\1"'</span>, content)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(file_path, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse_folder</span><span class="params">(folder_path)</span>:</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> root, _, files <span class="keyword">in</span> os.walk(folder_path):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            <span class="comment"># if x &gt; 100:</span></span><br><span class="line">            <span class="comment">#     return</span></span><br><span class="line">            <span class="keyword">if</span> file.endswith(<span class="string">".md"</span>):  <span class="comment"># 假设 Obsidian 笔记文件是以 .md 结尾</span></span><br><span class="line">                file_path = os.path.join(root, file)</span><br><span class="line">                replace_links(file_path)</span><br><span class="line">                print(<span class="string">f"Processed: <span class="subst">&#123;file_path&#125;</span>"</span>)</span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始遍历文件夹并替换链接</span></span><br><span class="line">traverse_folder(obsidian_folder)</span><br></pre></td></tr></table></figure><p>如果使用 PicGo 图片上传，搜索 <a href="https://github.com/wayjam/picgo-plugin-s3" target="_blank" rel="noopener">s3 插件</a>安装。</p><p>我个人网站文章使用 Obsidian 存放，当我替换 Obsidian 文档的图片链接后，个人网站文章的图片也就会<a href="https://depp.wang/2022/11/21/obsidian_to_hexoblog/">自动同步</a>替换了。</p><h1 id="如果你遇到图片打不开，或者加载比较慢，请给我留言反馈一下，感谢。"><a href="#如果你遇到图片打不开，或者加载比较慢，请给我留言反馈一下，感谢。" class="headerlink" title="如果你遇到图片打不开，或者加载比较慢，请给我留言反馈一下，感谢。"></a>如果你遇到图片打不开，或者加载比较慢，请给我留言反馈一下，感谢。</h1>]]></content:encoded>
      
      <comments>https://depp.wang/2024/image-from-oss-to-r2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>更简单的「有道云笔记」导出与备份</title>
      <link>https://depp.wang/2024/simple-youdaonote-pull/</link>
      <guid>https://depp.wang/2024/simple-youdaonote-pull/</guid>
      <pubDate>Tue, 18 Jun 2024 04:48:39 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;https://hexoblog.r2.depp.wang/20240618124244.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/deppwang/youdaonote-pull&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;youdaonote-pull&lt;/a&gt; 是我写的一个开源的有道云笔记导出与备份工具，同时可以将不是 Markdown 格式的笔记转换为 Markdown 格式。&lt;/p&gt;
&lt;p&gt;我写了比较详细的使用步骤，对于非技术人员的同学来说，可能还是有点门槛。所以我又花了些时间，将其简化了可直接本地运行程序，你不再需要安装 Git、Python 和下载代码。&lt;/p&gt;
&lt;p&gt;程序完全本地运行，无需担心隐私问题。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://hexoblog.r2.depp.wang/20240618124244.png" alt=""></p><p><a href="https://github.com/deppwang/youdaonote-pull" target="_blank" rel="noopener">youdaonote-pull</a> 是我写的一个开源的有道云笔记导出与备份工具，同时可以将不是 Markdown 格式的笔记转换为 Markdown 格式。</p><p>我写了比较详细的使用步骤，对于非技术人员的同学来说，可能还是有点门槛。所以我又花了些时间，将其简化了可直接本地运行程序，你不再需要安装 Git、Python 和下载代码。</p><p>程序完全本地运行，无需担心隐私问题。</p><a id="more"></a><p>以下是使用方法。</p><p>前置条件: </p><ol><li>有一台电脑，Windows / Mac / Linux 都可。</li><li>电脑上已经安装支持 Chrome 插件的浏览器，如 Google Chrome / Microsoft Edge。</li></ol><h2 id="1、下载程序"><a href="#1、下载程序" class="headerlink" title="1、下载程序"></a>1、下载程序</h2><p>在<a href="https://akkcmwhbj8.feishu.cn/drive/folder/LTdufMD2mlM1jNdxCizcq8thnAg" target="_blank" rel="noopener">此处</a>（密码: <code>61@8246K</code>）下载你电脑对应的运行程序压缩包，再解压。</p><p><img src="https://hexoblog.r2.depp.wang/20240617232804.png" alt=""></p><p>Windows 对应的运行程序压缩包内容：</p><p><img src="https://hexoblog.r2.depp.wang/20240617232831.png" alt=""></p><h2 id="2、安装浏览器插件复制登录-Cookie"><a href="#2、安装浏览器插件复制登录-Cookie" class="headerlink" title="2、安装浏览器插件复制登录 Cookie"></a>2、安装浏览器插件复制登录 Cookie</h2><p>有道云笔记登陆有图形验证码，所以程序无法直接通过账号密码的方式登录。所以需要你浏览器网页登录后，复制其登录 Cookie，有了 Cookie，程序才可以读取到你的有道云笔记数据。</p><p>可以通过安装一个插件（<a href="https://chromewebstore.google.com/detail/cookie-copy/igfcbpdchlohbhjdfbcimhbpajlglaac?hl=zh-CN&utm_source=ext_sidebar" target="_blank" rel="noopener">Cookie-copy</a>）快速复制 Cookie。</p><p><img src="https://hexoblog.r2.depp.wang/20240617232910.png" alt=""></p><p>浏览器中打开 chrome://extensions/ ，开启「开发者模式」，再将「Cookie-copy_0.0.4.crx」插件拖拽到此界面即可完成安装。</p><p><img src="https://hexoblog.r2.depp.wang/20240613172650.png" alt=""></p><video controls width="640" height="360">    <source src="https://hexoblog.r2.depp.wang/cookie-copy.mp4" type="video/mp4">  </video><p>登陆有道云笔记网页版本后，在  Cookie-copy 插件中复制这 3 个 Cookie：</p><ul><li><code>YNOTE_CSTK</code></li><li><code>YNOTE_LOGIN</code></li><li><code>YNOTE_SESS</code></li></ul><p><img src="https://hexoblog.r2.depp.wang/20240613172452.png" alt=""></p><p>Cookie-copy 插件使用完之后可以将其关闭或者移除。</p><h2 id="3、cookies-json-中配置-Cookie"><a href="#3、cookies-json-中配置-Cookie" class="headerlink" title="3、cookies.json 中配置 Cookie"></a>3、cookies.json 中配置 Cookie</h2><p>替换 cookies.json 中的复制 3 个参数，替换后结果应该如下所示：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"cookies"</span>: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">"YNOTE_CSTK"</span>,</span><br><span class="line">            <span class="string">"rR_Pejz0"</span>,</span><br><span class="line">            <span class="string">".note.youdao.com"</span>,</span><br><span class="line">            <span class="string">"/"</span></span><br><span class="line">        ],</span><br><span class="line">        [</span><br><span class="line">            <span class="string">"YNOTE_LOGIN"</span>,</span><br><span class="line">            <span class="string">"3||1649054441155"</span>,</span><br><span class="line">            <span class="string">".note.youdao.com"</span>,</span><br><span class="line">            <span class="string">"/"</span></span><br><span class="line">        ],</span><br><span class="line">        [</span><br><span class="line">            <span class="string">"YNOTE_SESS"</span>,</span><br><span class="line">            <span class="string">"v2|BdllbnwfaWl5RMUWOfqZ0gShf***6LqFRqB0MYfh4JLR"</span>,</span><br><span class="line">            <span class="string">".note.youdao.com"</span>,</span><br><span class="line">            <span class="string">"/"</span></span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、双击运行下载"><a href="#4、双击运行下载" class="headerlink" title="4、双击运行下载"></a>4、双击运行下载</h2><p><img src="https://hexoblog.r2.depp.wang/20240613220215.png" alt=""></p><p>双击程序运行，会打开终端执行。所有笔记会默认下载到当前目录的 youdaonote 文件夹中。会在 logs 目录存放运行日志。你也可以通过配置 config.json 实现下载指定目录，具体使用方法请看「<a href="https://github.com/DeppWang/youdaonote-pull?tab=readme-ov-file#4%E8%AE%BE%E7%BD%AE%E8%84%9A%E6%9C%AC%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-configjson" target="_blank" rel="noopener">这里</a>」。</p><p>效果示例：</p><p><img src="https://hexoblog.r2.depp.wang/20240618092919.png" alt=""></p><p>如果运行失败，可以根据错误日志排查。</p>]]></content:encoded>
      
      <comments>https://depp.wang/2024/simple-youdaonote-pull/#disqus_thread</comments>
    </item>
    
    <item>
      <title>为好软件付费</title>
      <link>https://depp.wang/2024/software-payment/</link>
      <guid>https://depp.wang/2024/software-payment/</guid>
      <pubDate>Sat, 15 Jun 2024 17:09:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;我看过一句话，想不起来出处了，大概意思是「最有价值的事是创造最棒的产品，而第二有价值的事是购买使用最棒的产品」。软件也是一种产品，同样适用这句话。&lt;/p&gt;
&lt;p&gt;年少的我也是白嫖党，随着年龄的增长，我逐渐转变思想，开始为好软件付费。每个人对好软件的标准不一样，我认为的好软件有这几个特点：经常使用、解决了特定的问题、同类软件使用体验最好。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>我看过一句话，想不起来出处了，大概意思是「最有价值的事是创造最棒的产品，而第二有价值的事是购买使用最棒的产品」。软件也是一种产品，同样适用这句话。</p><p>年少的我也是白嫖党，随着年龄的增长，我逐渐转变思想，开始为好软件付费。每个人对好软件的标准不一样，我认为的好软件有这几个特点：经常使用、解决了特定的问题、同类软件使用体验最好。</p> <a id="more"></a><p>人更愿意为看得见、摸得着的实体商品付费，如服饰鞋包、化妆品、电子产品。对于像软件这类虚拟商品，长期以来，微信/高德地图/抖音/百度等这类常用的软件是可以免费使用的，这可能是一个重要原因，导致我们潜意识就认为软件应该是免费的。</p><p>但软件这类虚拟商品的开发与维护也是需要成本的，有人力成本，也有运营成本。一个软件，你不需要付费就能使用，你就需要接受广告或你个人数据与行为被公司使用与出售的代价。正如 <a href="https://x.com/andlewis/status/24380177712" target="_blank" rel="noopener">Andrew Lewis 所说</a>，「如果你不需要为某产品付费，那么你就是那个产品本身」。公司付出的成本始终还是会从你身上赚回来，只是不是通过让你付费的方式。</p><p>当一个软件不向你展示广告，不出售你的个人数据。那它主要的盈利手段就是用户付费。</p><p>目前对于公司来说，通过购买软件来解决问题的方式越来越普遍。比如公司买云服务器来部署自己的产品，而不是自己购买物理服务器；购买飞书这类的产品来做企业内部沟通工具。</p><p>对于我们个体来说，我们不愿意向软件付费的还有一个重要原因，那就是现在很容易就能下载到破解软件，或者是盗版软件。在 Windows / Android / macOS 等平台，安装破解/盗版软件也很容易。人性使然，可以免费用，为什么还要付费。</p><p>如果你还没有自己的收入来源，你没有使用正版软件，倒也无可厚非。但当我们有了收入来源，使用破解/盗版软件，而省下的钱，我们用它做了什么？是买了杯奶茶，还是去下了个馆子。当我们收入不全是生活开支时，其它的支出就是消费，买奶茶是消费，下馆子也是消费，买正版软件也是消费。而购买的正版软件的最终体现的作用可能真的比一杯奶茶或者一顿美食更有价值。<strong>我们的消费支出中应该留给好软件付费留出位置</strong>。它和服饰鞋包、化妆品、电子产品等实体商品一样，值得我们付费。</p><p>消费促进经济，消费软件商品也可以促进经济。我们为软件付费，软件开发者可以靠自己的产品挣到钱，往大了说，这增加了就业机会，降低了失业率。购买正品软件是支持作者，同时也是潜在的支持我们自己，当更多人有了为好软件付费的意识，当你有产品需要用户付费时，你也能获得收入，甚至作为你主要收入来源。</p><p>我们换位思考，如果你是软件的开发者，你想你花费心血开发的付费软件被破解，被人免费使用吗？</p><p>我们使用破解/盗版软件其实也有一定的安全风险。网上有很多因为使用破解/盗版软件钱财被勒索或者被骗的案例。公司员工使用盗版软件，公司也有可能面临一定的法律风险。其实不少付费软件都有开源的软件可以替代，比如「Navicat Premium」有开源替代「<a href="https://github.com/dbeaver/dbeaver" target="_blank" rel="noopener">DBeaver</a>」。针对开源的软件，如果我们觉得不错，也可以为其赞赏，支持一下作者的付出。</p><p>我们通过付费来支持正版软件，我们当然也可以通过一些方式实现更具性价比的购买。以下是一些方式：</p><ul><li>软件开发者可能会在一些节日打折促销，如黑色星期五</li><li>很多软件可以多人合用一个账号（拼车），大家一起分摊费用。如 Netflix 可以在<a href="https://www.ihezu.cn/" target="_blank" rel="noopener">奈飞小铺</a>拼车</li><li>可以从国内的正版授权商购买（如<a href="https://www.lizhi.io/" target="_blank" rel="noopener">荔枝数码</a>），有的软件相比从官网买，有一定优惠。如 <a href="https://item.taobao.com/item.htm?id=663600199279&skuId=5114736058621" target="_blank" rel="noopener">Typora</a></li><li>不少软件有学生优惠，如果是在校学生，会有一定的折扣，如 Adobe 与 JetBrains 的软件</li><li>也有基于订阅模式的软件聚合平台，可以每月以固定的价格使用其平台包含的所有软件，如 <a href="https://setapp.com/" target="_blank" rel="noopener">SETAPP</a></li><li>不少软件在推广期会赠送一些授权码免费使用，或者价格很低就可以购入，在 V2EX 平台，就经常有这种软件推广</li><li>如果你积极参与开源，也可以免费使用的一些软件，如 JetBrains 的软件</li></ul><p>以下是我一些付费过与正在付费的软件：</p><p>付费过：</p><ol><li><a href="https://www.bypass.cn/" target="_blank" rel="noopener">分流抢票</a></li><li><a href="https://i.mi.com/" target="_blank" rel="noopener">小米云服务</a></li><li><a href="https://cloud.oppo.com/" target="_blank" rel="noopener">OPPO 云服务</a></li><li><a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">PyCharm</a></li><li><a href="https://yixi.tv/" target="_blank" rel="noopener">一席会员</a></li><li><a href="https://www.parallels.cn/" target="_blank" rel="noopener">Parallels</a></li><li><a href="https://dida365.com/" target="_blank" rel="noopener">滴答清单</a></li><li><a href="https://toolinbox.net/iPic/" target="_blank" rel="noopener">iPic</a></li><li><a href="https://github.com/features/copilot" target="_blank" rel="noopener">GitHub Copilot</a></li><li><a href="https://chatgpt.com/" target="_blank" rel="noopener">ChatGPT Plus</a></li><li><a href="https://raindrop.io/" target="_blank" rel="noopener">Raindrop.io</a></li><li><a href="https://www.nytimes.com/" target="_blank" rel="noopener">NYTimes</a></li><li><a href="https://x.com/i/premium_sign_up" target="_blank" rel="noopener">X(Twitter)</a></li><li><a href="https://www.apple.com/apple-arcade/" target="_blank" rel="noopener">Apple Arcade</a></li><li><a href="https://obsidian.md/sync" target="_blank" rel="noopener">Obsidian Sync</a></li><li><a href="https://firecore.com/infuse" target="_blank" rel="noopener">Infuse</a></li></ol><p>买断：</p><ol><li><a href="https://www.alfredapp.com/workflows/" target="_blank" rel="noopener">Alfred4 Workflows</a></li><li><a href="https://manico.im/" target="_blank" rel="noopener">Manico</a></li><li><a href="https://apps.apple.com/us/app/pphub-for-github-developer/id1314212521" target="_blank" rel="noopener">PPHub</a></li><li><a href="https://workingcopyapp.com/" target="_blank" rel="noopener">Working Copy</a></li><li><a href="https://apps.apple.com/us/app/shadowrocket/id932747118" target="_blank" rel="noopener">Shadowrocket</a></li><li><a href="https://apps.apple.com/us/app/stash-rule-based-proxy/id1596063349" target="_blank" rel="noopener">Stash</a></li><li><a href="https://typora.io/" target="_blank" rel="noopener">Typora</a></li></ol><p>正在付费：</p><ul><li><a href="https://plus.jd.com/" target="_blank" rel="noopener">京东 Plus</a></li><li><a href="https://www.bilibili.com/" target="_blank" rel="noopener">BiliBili 大会员</a></li><li><a href="https://www.netflix.com/" target="_blank" rel="noopener">Netflix</a></li><li><a href="https://zh.okaapps.com/product/1659622164" target="_blank" rel="noopener">VidHub</a></li><li><a href="https://bandwagonhost.com/" target="_blank" rel="noopener">搬瓦工 VPS</a></li><li><a href="https://www.apple.com/apple-music/" target="_blank" rel="noopener">Apple Music</a></li><li><a href="https://www.icloud.com/" target="_blank" rel="noopener">美区 iCloud</a></li><li><a href="https://www.cloudflare.com/products/argo-smart-routing/" target="_blank" rel="noopener">Cloudflare - Argo Smart Routing</a></li></ul><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://retompi.com/archived-blog/posts/2019/12/02/we-should-use-genuine-softwares.html" target="_blank" rel="noopener">喝奶茶或买软件，你选哪一个？</a></li></ul>]]></content:encoded>
      
      <comments>https://depp.wang/2024/software-payment/#disqus_thread</comments>
    </item>
    
    <item>
      <title>实现 GPT-4o 使用自由</title>
      <link>https://depp.wang/2024/gpt4o-free-use/</link>
      <guid>https://depp.wang/2024/gpt4o-free-use/</guid>
      <pubDate>Tue, 11 Jun 2024 13:11:41 GMT</pubDate>
      <description>
      
        &lt;p&gt;国外大语言模型三方评测网站 &lt;a href=&quot;https://artificialanalysis.ai/models&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Artificial Analysis&lt;/a&gt; 的评测结果显示：GPT-4o 质量是目前所有大语言模型中最好的，速度比 GPT-3.5 Turbo 快，API 的价格相比 GPT-4 也降低了一半。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexoblog.r2.depp.wang/20240611190755.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>国外大语言模型三方评测网站 <a href="https://artificialanalysis.ai/models" target="_blank" rel="noopener">Artificial Analysis</a> 的评测结果显示：GPT-4o 质量是目前所有大语言模型中最好的，速度比 GPT-3.5 Turbo 快，API 的价格相比 GPT-4 也降低了一半。</p><p><img src="https://hexoblog.r2.depp.wang/20240611190755.png" alt=""></p><a id="more"></a><h2 id="有网络条件，可以免费使用-GPT-4o"><a href="#有网络条件，可以免费使用-GPT-4o" class="headerlink" title="有网络条件，可以免费使用 GPT-4o"></a>有网络条件，可以免费使用 GPT-4o</h2><p>目前有一些方式可以免费使用 GPT-4o，但都有自己的局限性。</p><ol><li><p>ChatGPT 注册用户在<a href="https://chatgpt.com/" target="_blank" rel="noopener">网页端</a>与客户端每日可以免费限量使用。这种方式对网络要求比较高</p></li><li><p><a href="https://poe.com/GPT-4o" target="_blank" rel="noopener">Poe</a> 网络要求相对低一点，但每天只能免费使用 10 次</p></li><li><p><a href="https://copilot.microsoft.com/" target="_blank" rel="noopener">Microsoft Copilot</a> 可免费使用，手机客户端网络要求低点，网页端的网络要求比较高</p><p><a href="https://www.coze.com/home" target="_blank" rel="noopener">Coze</a> 通过配置自定义机器人的方式显示可以免费使用 GPT-4o，但我实际测试发现其模型应该是 GPT-3.5。</p></li></ol><p><img src="https://hexoblog.r2.depp.wang/20240611210411.png" alt=""></p><h2 id="没有网络条件，可以通过-API-Key-使用-GPT-4o"><a href="#没有网络条件，可以通过-API-Key-使用-GPT-4o" class="headerlink" title="没有网络条件，可以通过 API Key 使用 GPT-4o"></a>没有网络条件，可以通过 API Key 使用 GPT-4o</h2><p>如果你能解决网络问题，ChatGPT 注册用户的免费额度应该够你用了。如果你不能解决网络问题，那可以通过 API Key 的方式来使用。</p><p>如果你没有 OpenAI 的 API Key，你可以在专门售卖的 OpenAI API 能力的服务商处购买，如 <a href="https://aiproxy.io/pricing" target="_blank" rel="noopener">aiproxy.io</a>。直接充值积分。我在这个服务商买过，价格还是比较合理，也是真的 OpenAI 的 API。</p><p>建议自己搭建一个基于 API Key 自用的网页服务来使用，使用其它人搭建的网页服务还是有一定的 API Key 泄露的风险。</p><p>目前可以搭建基于 API Key 的网页服务的开源项目有很多，我使用的 <a href="https://github.com/Yidadaa/ChatGPT-Next-Web" target="_blank" rel="noopener">ChatGPT-Next-Web</a>，它可以一键部署到  <a href="https://vercel.com/" target="_blank" rel="noopener">Vercel</a> 上。Vercel 每月有一定的额度可以免费使用，我们不用另外购买云主机。因为 Vercel 是国外公司，所以你国内访问时，网络性能不是很好。你可以利用自定义域名，使用 <a href="https://dash.cloudflare.com/" target="_blank" rel="noopener">Cloudflare</a> 免费配置域名转发，加快国内网络访问的速度。</p><p>以下是我基于 ChatGPT-Next-Web 搭建的自用网页服务，部署在 Vercel 上，使用了自定义域名 <a href="https://chatgpt.depp.wang" target="_blank" rel="noopener">https://chatgpt.depp.wang</a></p><p><img src="https://hexoblog.r2.depp.wang/20240611201010.png" alt=""></p><p>区分 GPT-3.5 和 GPT-4o 可以问：「为什么父母结婚没有邀请我」，GPT-4o 会回答可能因为你还没有出生。也可以直接问它是不是基于 GPT-4o。</p><p>如果你想免费使用 API Key。如果你有公司邮箱、公司有官网地址。你可以通过申请试用 Mircosoft Azure 的  <a href="https://azure.microsoft.com/en-us/products/ai-services/openai-service/" target="_blank" rel="noopener">OpenAI 服务</a>实现。Azure 为新注册用户赠送 200 美金，可以用来付 API 账单，这 200 美金有效期有 1 个月。</p><h2 id="国内网络使用-GPT3-5-或国内大语言模型"><a href="#国内网络使用-GPT3-5-或国内大语言模型" class="headerlink" title="国内网络使用 GPT3.5 或国内大语言模型"></a>国内网络使用 GPT3.5 或国内大语言模型</h2><p>如果你日常对模型要求没有那么高，你可以通过 ChatGPT-Next-Web 使用 GPT-3.5，目前 GPT-3.5 API 的价格还是很便宜的，可能比你去某些网站注册买会员更便宜。你也可以使用国内网络条件就可以直接用的国内公司开发的大语言模型。比如：</p><ul><li><a href="https://www.coze.cn/" target="_blank" rel="noopener">扣子</a> - 字节跳动推出的 AI Bot 开发平台</li><li><a href="https://www.doubao.com/" target="_blank" rel="noopener">豆包</a> - 抖音旗下 AI 智能助手</li><li><a href="https://tongyi.aliyun.com/qianwen/" target="_blank" rel="noopener">通义千问</a>- 阿里巴巴开发的 AI 大语言模型</li><li><a href="https://yuanbao.tencent.com/chat" target="_blank" rel="noopener">元宝</a> - 腾讯开发的 AI 大语言模型</li><li><a href="https://yiyan.baidu.com/" target="_blank" rel="noopener">文心一言</a> - 百度开发的 AI 大语言模型</li><li><a href="https://hailuoai.com/" target="_blank" rel="noopener">海螺 AI</a> - MiniMax 旗下的 AI 产品</li></ul>]]></content:encoded>
      
      <comments>https://depp.wang/2024/gpt4o-free-use/#disqus_thread</comments>
    </item>
    
    <item>
      <title>从 FastAPI 说起，理解 Python 异步 IO 的原理</title>
      <link>https://depp.wang/2024/python-async-io/</link>
      <guid>https://depp.wang/2024/python-async-io/</guid>
      <pubDate>Sun, 02 Jun 2024 16:27:30 GMT</pubDate>
      <description>
      
        &lt;p&gt;因为 Python 是解释型语言，当使用 Python 做后端开发时，如 Python + Django，相比 Java + Spring，其响应时间会长一点，但只要代码合理，差别也不太大。但 Django 即使使用多进程模式，其并发处理能力还是会差不少。Python 有一些提升并发处理能力的方案，比如使用异步框架 FastAPI，借助其异步能力，可以大大提升 IO 密集型任务的并发处理能力。FastAPI 算是&lt;a href=&quot;https://www.techempower.com/benchmarks/#hw=ph&amp;test=query&amp;section=data-r22&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最快的 Python 框架之一&lt;/a&gt;。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>因为 Python 是解释型语言，当使用 Python 做后端开发时，如 Python + Django，相比 Java + Spring，其响应时间会长一点，但只要代码合理，差别也不太大。但 Django 即使使用多进程模式，其并发处理能力还是会差不少。Python 有一些提升并发处理能力的方案，比如使用异步框架 FastAPI，借助其异步能力，可以大大提升 IO 密集型任务的并发处理能力。FastAPI 算是<a href="https://www.techempower.com/benchmarks/#hw=ph&test=query&section=data-r22" target="_blank" rel="noopener">最快的 Python 框架之一</a>。</p><a id="more"></a><h2 id="FastAPI"><a href="#FastAPI" class="headerlink" title="FastAPI"></a>FastAPI</h2><p>我们先简单看看 FastAPI 怎么用。</p><h3 id="示例-1：默认网络异步-IO"><a href="#示例-1：默认网络异步-IO" class="headerlink" title="示例 1：默认网络异步 IO"></a>示例 1：默认网络异步 IO</h3><p>安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m venv venv</span><br><span class="line">. ./venv/bin/activate</span><br><span class="line">pip install fastapi</span><br></pre></td></tr></table></figure><p>简单的 Server 端代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Union</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get("/")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_root</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"Hello"</span>: <span class="string">"World"</span>&#125;</span><br></pre></td></tr></table></figure><p>启动：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uvicorn main:app --reload</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://hexoblog.r2.depp.wang/20240602232755.png" alt=""></p><p>我们可以看出，FastAPI 的接口相比其它框架，写法只是多了个 async 关键字，async 定义接口是异步的。</p><p>单从返回结果中看不出来 FastAPI 与其它 Python 框架的区别。区别在于并发访问时，FastAPI 的服务器线程处理路由请求，如 <code>http://127.0.0.1:8000/</code>，如果遇到网络 IO，不再等待网络 IO，而是去处理其它请求，当网络 IO 完成时，再恢复继续执行，这个异步能力提升了对 IO 密集型任务的处理能力。</p><h3 id="示例-2：显式网络异步-IO"><a href="#示例-2：显式网络异步-IO" class="headerlink" title="示例 2：显式网络异步 IO"></a>示例 2：显式网络异步 IO</h3><p>再看另一个示例，在业务代码中，显式的发起异步网络请求，这个网络 IO，如同路由请求一样，FastAPI 也会异步的处理。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, HTTPException</span><br><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步 GET 请求示例</span></span><br><span class="line"><span class="meta">@app.get("/external-api")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">call_external_api</span><span class="params">()</span>:</span></span><br><span class="line">    url = <span class="string">"https://jsonplaceholder.typicode.com/posts/1"</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> httpx.AsyncClient() <span class="keyword">as</span> client:</span><br><span class="line">        response = <span class="keyword">await</span> client.get(url)</span><br><span class="line">        <span class="keyword">if</span> response.status_code != <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">raise</span> HTTPException(status_code=response.status_code, detail=<span class="string">"Failed to fetch data"</span>)</span><br><span class="line">        <span class="keyword">return</span> response.json()</span><br></pre></td></tr></table></figure><p><img src="https://hexoblog.r2.depp.wang/20240602215253.png" alt=""></p><p>如果想数据库 IO 异步，需要数据库驱动或 ORM 支持异步操作。</p><h2 id="异步-IO"><a href="#异步-IO" class="headerlink" title="异步 IO"></a>异步 IO</h2><p>FastAPI 异步的核心实现是「异步 IO」，我们可以不用 FastAPI，直接使用异步 IO 来启动一个有异步处理能力的 Server。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>) <span class="comment"># 模拟 I/O 操作</span></span><br><span class="line">    <span class="keyword">return</span> web.Response(text=<span class="string">'&#123;"Hello": "World"&#125;'</span>, content_type=<span class="string">'application/json'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(loop)</span>:</span></span><br><span class="line">    <span class="comment"># 使用事件循环监控 web 请求</span></span><br><span class="line">    app = web.Application(loop=loop)</span><br><span class="line">    app.router.add_route(<span class="string">'GET'</span>, <span class="string">'/'</span>, index)</span><br><span class="line">    <span class="comment"># 启动 server，事件循环监控处理 web 请求</span></span><br><span class="line">    srv = <span class="keyword">await</span> loop.create_server(app.make_handler(), <span class="string">'127.0.0.1'</span>, <span class="number">8000</span>)</span><br><span class="line">    print(<span class="string">'Server started at http://127.0.0.1:8000...'</span>)</span><br><span class="line">    <span class="keyword">return</span> srv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显式获取一个事件循环</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 启动事件循环</span></span><br><span class="line">loop.run_until_complete(init(loop))</span><br><span class="line">loop.run_forever()</span><br></pre></td></tr></table></figure><p>启动这个示例， <code>http://127.0.0.1:8000/</code> 返回结果跟示例 1 一样。</p><p>异步 IO 的底层实现原理是「协程」与「事件循环」。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>) <span class="comment"># 模拟 I/O 操作</span></span><br><span class="line">    <span class="keyword">return</span> web.Response(text=<span class="string">'&#123;"Hello": "World"&#125;'</span>, content_type=<span class="string">'application/json'</span>)</span><br></pre></td></tr></table></figure><p>index 使用  <code>async def</code>  定义，代表它是一个协程。<code>await</code> 用于 I/O 操作前，告诉执行线程不用等待这个 IO 操作。正常函数的调用是通过栈实现，函数只能依次调用执行。而协程 （coroutine）是一种特殊的函数（不是协作的线程），它可以让线程在 await 标记处暂停执行，转而执行其它任务，当 IO 操作完全时，再继续执行。</p><p>我们看看多个协程并发执行的效果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coroutine3</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">f"Coroutine 3 started at <span class="subst">&#123;datetime.now()&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)  <span class="comment"># 模拟 I/O 操作</span></span><br><span class="line">    print(<span class="string">f"Coroutine 3 finished at <span class="subst">&#123;datetime.now()&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coroutine2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">f"Coroutine 2 started at <span class="subst">&#123;datetime.now()&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)  <span class="comment"># 模拟 I/O 操作</span></span><br><span class="line">    print(<span class="string">f"Coroutine 2 finished at <span class="subst">&#123;datetime.now()&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coroutine1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">f"Coroutine 1 started at <span class="subst">&#123;datetime.now()&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)  <span class="comment"># 模拟 I/O 操作</span></span><br><span class="line">    print(<span class="string">f"Coroutine 1 finished at <span class="subst">&#123;datetime.now()&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Main started"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建任务，让协程并发执行</span></span><br><span class="line">    task1 = asyncio.create_task(coroutine1())</span><br><span class="line">    task2 = asyncio.create_task(coroutine2())</span><br><span class="line">    task3 = asyncio.create_task(coroutine3())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待所有任务完成</span></span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line">    <span class="keyword">await</span> task3</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"Main finished"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行主协程</span></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Main started</span><br><span class="line">Coroutine 1 started at 2024-06-03 10:28:00.665051</span><br><span class="line">Coroutine 2 started at 2024-06-03 10:28:00.665076</span><br><span class="line">Coroutine 3 started at 2024-06-03 10:28:00.665087</span><br><span class="line">Coroutine 1 finished at 2024-06-03 10:28:01.665265</span><br><span class="line">Coroutine 2 finished at 2024-06-03 10:28:01.665310</span><br><span class="line">Coroutine 3 finished at 2024-06-03 10:28:01.665319</span><br><span class="line">Main finished</span><br></pre></td></tr></table></figure><p>我们可以看出，线程没有依次执行 3 个任务，遇到 IO 操作时，转而执行了其它任务。等 IO 操作完成后，再接着执行。也可以看出线程 3 个协程基本是同时开启等待 I/O 操作的，所以最终执行完成时间基本相同。</p><p>虽然这里没有显式使用事件循环，但 <code>asyncio.run</code> 会隐式的使用使用事件循环。</p><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>协程是通过生成器实现的。生成器可以让函数执行暂停，也可以让函数执行恢复。也就是协程的特点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_generator</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"First value"</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    print(<span class="string">"Second value"</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    print(<span class="string">"Third value"</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># simple_generator 是生成器函数, gen 是生成器</span></span><br><span class="line">gen = simple_generator() </span><br><span class="line"></span><br><span class="line">print(next(gen))  <span class="comment"># 输出: First value \n 1</span></span><br><span class="line">print(next(gen))  <span class="comment"># 输出: Second value \n 2</span></span><br><span class="line">print(next(gen))  <span class="comment"># 输出: Third value \n 3</span></span><br></pre></td></tr></table></figure><p>使用 <code>next()</code> 运行生成器时，遇到 <code>yield</code> 时，它将暂停，next() 再次运行时，会接着上次暂停的 yield 处继续运行。Python 3.5 以前的协程写法也是使用「注解」+ <code>yeild</code>，3.5 开始使用 <code>async def</code> + <code>await</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_coroutine</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Start coroutine"</span>, datetime.now())</span><br><span class="line">    <span class="comment"># 异步调用 asyncio.sleep(1):</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"End coroutine"</span>, datetime.now())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 EventLoop</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 执行 coroutine</span></span><br><span class="line">loop.run_until_complete(my_coroutine())</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure><p>生成器的运行暂停与恢复的特点，除了做协程，还可以做不少事，可以边循环边计算，存放算法，比如实现一个杨辉三角（每一行的两端都是 1，其他位置的数字是它上方两个数字之和）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yanghui_triangle</span><span class="params">()</span>:</span></span><br><span class="line">    row = [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> row</span><br><span class="line">        new_row = [<span class="number">1</span>]  <span class="comment"># 每一行的第一个元素总是 1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(row)):</span><br><span class="line">            new_row.append(row[i - <span class="number">1</span>] + row[i])</span><br><span class="line">        new_row.append(<span class="number">1</span>)  <span class="comment"># 每一行的最后一个元素总是 1</span></span><br><span class="line">        row = new_row</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成并打印前 5 行杨辉三角</span></span><br><span class="line">triangle = yanghui_triangle()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    print(next(triangle))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>协程执行可以暂停，那协程何时恢复执行，这就需要使用事件循环来告诉执行线程。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取 EventLoop</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 事件循环执行 coroutine</span></span><br><span class="line">loop.run_until_complete(my_coroutine())</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure><p>事件循环是使用 IO 多路复用技术，一直循环监控协程可以继续执行的事件，当可以执行时，线程继续执行协程。</p><h3 id="IO-多路复用技术"><a href="#IO-多路复用技术" class="headerlink" title="IO 多路复用技术"></a>IO 多路复用技术</h3><p>通俗理解 IO 多路复用：我是快递站点老板，我不用主动问每个快递员的任务完成情况，而是快递员自己完成任务后，主动通过我。这提高了我处理任务的能力，我这个老板可以做更多的事。</p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">+--------+  +--------+  +--------+</span><br><span class="line">|<span class="string">快递员 A</span>|<span class="string">--&gt;</span>|<span class="string">快递员 B</span>|<span class="string">--&gt;</span>|<span class="string">快递员 C</span>|</span><br><span class="line">|<span class="string">任务完成</span>|<span class="string">   </span>|<span class="string">任务完成</span>|<span class="string">   </span>|<span class="string">任务完成</span>|</span><br><span class="line">+--------+  +--------+  +--------+</span><br><span class="line">       \        |<span class="string">         /</span></span><br><span class="line"><span class="string">        \       </span>|<span class="string">        /</span></span><br><span class="line"><span class="string">         \      </span>|<span class="string">       /</span></span><br><span class="line"><span class="string">          \     </span>|<span class="string">      /</span></span><br><span class="line"><span class="string">           \    </span>|<span class="string">     /</span></span><br><span class="line"><span class="string">            \   </span>|<span class="string">    /</span></span><br><span class="line"><span class="string">             \  </span>|<span class="string">   /</span></span><br><span class="line"><span class="string">              \ </span>|<span class="string">  /</span></span><br><span class="line"><span class="string">               \</span>|<span class="string"> /</span></span><br><span class="line"><span class="string">                V</span></span><br><span class="line"><span class="string">            +-------+</span></span><br><span class="line"><span class="string">            </span>|<span class="string">等待通知</span>|</span><br><span class="line">            +-------+</span><br><span class="line">                |</span><br><span class="line"><span class="string">                V</span></span><br><span class="line"><span class="string">            +-------+</span></span><br><span class="line"><span class="string">            </span>|<span class="string">处理任务</span>|</span><br><span class="line">            +-------+</span><br></pre></td></tr></table></figure><p>select、poll、epoll 都能实现  IO 多路复用，相比 select、poll，epoll 的性能更好。Linux 一般默认使用 epoll，macOS 使用 kqueue，类似于 epoll，跟 epoll 性能差不多。</p><h3 id="Socket-服务器使用事件循环"><a href="#Socket-服务器使用事件循环" class="headerlink" title="Socket 服务器使用事件循环"></a>Socket 服务器使用事件循环</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> selectors</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 selectors 对象，相于 epoll 的实现，Linux 中运行的话</span></span><br><span class="line">sel = selectors.DefaultSelector()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求接收事件处理函数。接受新的连接并注册读事件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span><span class="params">(sock, mask)</span>:</span></span><br><span class="line">    conn, addr = sock.accept()  <span class="comment"># 接受连接</span></span><br><span class="line">    print(<span class="string">'Accepted connection from'</span>, addr)</span><br><span class="line">    conn.setblocking(<span class="keyword">False</span>)</span><br><span class="line">    sel.register(conn, selectors.EVENT_READ, read)  <span class="comment"># 注册读取事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求读取事件处理函数。读取请求数据并发送 HTTP 响应，之后关闭连接。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(conn, mask)</span>:</span></span><br><span class="line">    data = conn.recv(<span class="number">100</span>)  <span class="comment"># 从连接中读取数据</span></span><br><span class="line">    print(<span class="string">'response to'</span>)</span><br><span class="line">    response = <span class="string">"HTTP/1.1 200 OK\r\n"</span> \</span><br><span class="line">            <span class="string">"Content-Type: application/json\r\n"</span> \</span><br><span class="line">            <span class="string">"Content-Length: 18\r\n"</span> \</span><br><span class="line">            <span class="string">"Connection: close\r\n"</span> \</span><br><span class="line">            <span class="string">"\r\n"</span> \</span><br><span class="line">            <span class="string">"&#123;\"Hello\": \"World\"&#125;"</span></span><br><span class="line">    conn.send(response.encode())  <span class="comment"># 回显数据</span></span><br><span class="line">    print(<span class="string">'Closing connection'</span>)</span><br><span class="line">    sel.unregister(conn)  <span class="comment"># 注销事件</span></span><br><span class="line">    conn.close()  <span class="comment"># 关闭连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个服务器 socket</span></span><br><span class="line">sock = socket.socket()</span><br><span class="line">sock.bind((<span class="string">'localhost'</span>, <span class="number">8000</span>))</span><br><span class="line">sock.listen()</span><br><span class="line">sock.setblocking(<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注册 accept 事件</span></span><br><span class="line">sel.register(sock, selectors.EVENT_READ, accept)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Server is running on port 8000..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 事件循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># 当没有请求时，这里会阻塞</span></span><br><span class="line">    events = sel.select()  <span class="comment"># 选择已准备好的文件描述符（事件）</span></span><br><span class="line">    print(<span class="string">"events length: "</span>, len(events))</span><br><span class="line">    <span class="keyword">for</span> key, mask <span class="keyword">in</span> events:</span><br><span class="line">        callback = key.data  <span class="comment"># 获取事件处理函数</span></span><br><span class="line">        print(<span class="string">"事件函数名:"</span>, callback.__name__)</span><br><span class="line">        callback(key.fileobj, mask)  <span class="comment"># 调用事件处理函数</span></span><br></pre></td></tr></table></figure><p>启动服务器 Socket，监控指定端口。如果运行在 Linux 系统上，selectors 默认使用 epoll 作为其实现。代码使用 epoll 注册一个请求接收事件（accept 事件）。当有新的请求到来时，epoll 会触发并执行该事件处理函数，同时注册一个读取事件（read 事件）用于处理和响应请求数据。</p><p>当 WEB 端使用 <a href="http://127.0.0.1:8000/" target="_blank" rel="noopener">http://127.0.0.1:8000/</a> 访问时，返回结果与示例 1 一样，Server 运行日志：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Server is running on port 8000...</span><br><span class="line">events length:  1</span><br><span class="line">事件函数名: accept</span><br><span class="line">Accepted connection from ('127.0.0.1', 60941)</span><br><span class="line">events length:  1</span><br><span class="line">事件函数名: read</span><br><span class="line">response to</span><br><span class="line">Closing connection</span><br></pre></td></tr></table></figure><h3 id="Socket-服务器"><a href="#Socket-服务器" class="headerlink" title="Socket 服务器"></a>Socket 服务器</h3><p>直接使用 Socket 启动一个 Server，浏览器使用 <a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080/</a> 访问或使用 <code>curl http://127.0.0.1:8080/</code> 返回 <code>{&quot;Hello&quot;: &quot;World&quot;}</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 TCP socket</span></span><br><span class="line">server_socket = socket.socket()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 socket 绑定到指定的IP地址和端口号</span></span><br><span class="line">server_socket.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8001</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始监听传入连接</span></span><br><span class="line">server_socket.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环接受客户端连接</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    print(<span class="string">"%s Waiting for a connection..."</span> % datetime.now())</span><br><span class="line">    client_socket, addr = server_socket.accept() <span class="comment"># 这里会阻塞，等待客户端连接</span></span><br><span class="line">    print(<span class="string">f"<span class="subst">&#123;datetime.now()&#125;</span> Got connection from <span class="subst">&#123;addr&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收客户端数据</span></span><br><span class="line">    data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">    print(<span class="string">f"Received: <span class="subst">&#123;data.decode()&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送响应数据</span></span><br><span class="line">    response = <span class="string">"HTTP/1.1 200 OK\r\n"</span> \</span><br><span class="line">               <span class="string">"Content-Type: application/json\r\n"</span> \</span><br><span class="line">               <span class="string">"Content-Length: 18\r\n"</span> \</span><br><span class="line">               <span class="string">"Connection: close\r\n"</span> \</span><br><span class="line">               <span class="string">"\r\n"</span> \</span><br><span class="line">               <span class="string">"&#123;\"Hello\": \"World\"&#125;"</span></span><br><span class="line">               </span><br><span class="line">    client_socket.sendall(response.encode())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭客户端套接字</span></span><br><span class="line">    client_socket.close()</span><br></pre></td></tr></table></figure><p><code>curl http://127.0.0.1:8001/</code> 访问，Server 运行日志：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2024-06-03 09:53:36.711732 Waiting for a connection...</span><br><span class="line">2024-06-03 09:54:30.715928 Got connection from ('127.0.0.1', 64361)</span><br><span class="line">Received: GET / HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8001</span><br><span class="line">User-Agent: curl/8.4.0</span><br><span class="line">Accept: */*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2024-06-03 09:54:30.716046 Waiting for a connection...</span><br></pre></td></tr></table></figure><h2 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h2><p>异步 IO 底层使用「协程」与「事件循环」实现。「协程」保证当线程执行时遇到标记的 IO 操作时，可以不用等待 IO 完成，而是暂停，让线程可以执行其他任务，不阻塞线程。「事件循环」使用 IO 多路复用技术，一直循环监控 IO 事件，当某个 IO 事件完成时，触发对应的回调，使协程继续执行。</p><p><img src="https://hexoblog.r2.depp.wang/1_50wqD04jyUiujKlIgQY47w.webp" alt=""></p><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><ul><li><a href="https://fastapi.tiangolo.com/zh/async/" target="_blank" rel="noopener">FastAPI - 并发 async / await</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017959540289152" target="_blank" rel="noopener">廖雪峰 - Python 教程 - 异步 IO</a></li></ul>]]></content:encoded>
      
      <comments>https://depp.wang/2024/python-async-io/#disqus_thread</comments>
    </item>
    
    <item>
      <title>我家的装修设计</title>
      <link>https://depp.wang/2024/decoration-design/</link>
      <guid>https://depp.wang/2024/decoration-design/</guid>
      <pubDate>Mon, 27 May 2024 05:01:54 GMT</pubDate>
      <description>
      
        &lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/kXnn_NE86vI?si=5XAHE2cZW-nyxx6R&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; referrerpolicy=&quot;strict-origin-when-cross-origin&quot; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;分享一下我家装修设计的一些经验。我是去年装修的，已经入住了，现在对装修结果还是比较满意。&lt;/p&gt;
&lt;p&gt;现在每个年轻人基本都会经历一下房子装修的过程，我在经历这个过程后，觉得还是有一些东西值得分享。&lt;/p&gt;
&lt;p&gt;我房子面积不大，所以对房子的设计没有去追求设计感，而是更多注重空间的利用性与功能的实用性。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<iframe width="560" height="315" src="https://www.youtube.com/embed/kXnn_NE86vI?si=5XAHE2cZW-nyxx6R" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>分享一下我家装修设计的一些经验。我是去年装修的，已经入住了，现在对装修结果还是比较满意。</p><p>现在每个年轻人基本都会经历一下房子装修的过程，我在经历这个过程后，觉得还是有一些东西值得分享。</p><p>我房子面积不大，所以对房子的设计没有去追求设计感，而是更多注重空间的利用性与功能的实用性。</p><a id="more"></a><p>有两个人的对我的装修设计影响比较大，一个是「齐洪海」，他在一席上分享了他的「<a href="https://yixi.tv/#/speech/detail?id=992" target="_blank" rel="noopener">家设计指南</a>」，让我了解到了一些原来没有意识到的思想，比如：「设计的实现不是在竣工的那一刻，而是在设计使用了一段时间以后」、比如：「家居设计中，入口区域的技术含量是最高的」。另一个是「<a href="https://space.bilibili.com/409883855?spm_id_from=333.337.0.0" target="_blank" rel="noopener">吉设计师</a>」，他是我通过<a href="https://www.bilibili.com/video/BV1Ca411g7Ko/" target="_blank" rel="noopener">麦克老师的视频</a>了解到的，后面我找他做了平面设计优化，他给我出了 2 个很好的方案，他的一些设计思路的也是我自己完全没有想到的。</p><h2 id="平面设计优化"><a href="#平面设计优化" class="headerlink" title="平面设计优化"></a>平面设计优化</h2><p>我房子的原始户型比较差，大门对着卧室门；生活阳台主要当过道了，空间比较浪费；卫生间很小，无法做三分离。</p><p><img src="https://hexoblog.r2.depp.wang/20240527161357.png" alt=""></p><p>我通过看小红书设计和自己琢磨，设计了一下户型。主要包括厨房从生活阳台借点空间，做成 U 型；生活阳台门从卫生间开；入户设计个玄关遮挡。但由于卫生间的面积太小，想做 3 段式实在有点捉襟见处。为了有更多的储藏，我设计了主卧床靠墙，使用也不太方便。</p><p><img src="https://hexoblog.r2.depp.wang/20240527161454.png" alt=""></p><p>所以我对吉设计师提出的诉求主要是卫生间这块的，希望能做成三段式，另外就是储藏多一点。他给我出了 2 套方案，第一套方案的卫生间设计我很喜欢， 将淋浴区域当过道，很有想像力的一个点。</p><p><img src="https://hexoblog.r2.depp.wang/20240527164751.png" alt=""></p><p>他后面又给我出了一个大胆的方案，将原来的厨房区域设计为卫生间，卫生间与生活阳台区域设计为开放式厨房。</p><p><img src="https://hexoblog.r2.depp.wang/20240527164913.png" alt=""></p><p>我认真考虑过这个方案，但由于厨房没有像卫生间那样有下沉空间，排水不能做坡度，只能使用扁型排水管，这对排水能力有一定影响，后期可能会堵。也只能使用墙排马桶，这降低了马桶的选择范围。厨房设计成开放式，如果想更好的隔绝油烟效果，需要使用玻璃等，这增大的施工难度与预算。但我对卧室这边的设计很满意，卧室门改了位置，不再对入户门，也有了 2 个 1.6 米宽的储藏空间，同时床也不挨着墙，更实用。</p><p>所以我选择吸收 2 个方案各自好的一部分设计，将其合为了一个方案。在这个方案上，我也做了一些适合自己的设计。接下来我会先说一下我家的电源/灯光与全屋智能设计，再针对我家空间，依次说下入口、卫生间、生活阳台、厨房、厅、卧室这 6 个空间的设计。</p><p><img src="https://hexoblog.r2.depp.wang/20240527165030.png" alt=""></p><h2 id="电源-灯光与全屋智能设计"><a href="#电源-灯光与全屋智能设计" class="headerlink" title="电源/灯光与全屋智能设计"></a>电源/灯光与全屋智能设计</h2><p>电源/灯光与全屋智能设计也其实对应的就是装修阶段的水电设计，一般来说，灯光设计决定你是否需要吊顶，我没有追求无主灯设计而全屋吊顶，基本没怎么吊顶，参观了不少同户型设计后，我使用了明装筒灯与射灯，客厅也装了主灯。</p><table><thead><tr><th>客厅灯</th><th>餐厅灯</th></tr></thead><tbody><tr><td><img src="https://hexoblog.r2.depp.wang/EDA39263-52FC-455A-854A-D6A42AF97637_1_105_c.jpeg" alt=""></td><td><img src="https://hexoblog.r2.depp.wang/BF553095-7A29-4F5A-829D-7568B362A4C1_1_105_c.jpeg" alt=""></td></tr></tbody></table><p>电源这方面，我插座设计的得还是比较多的，我先说几个个人觉得设计得还比较好的插座，其它的一些插座设计后面我也会提到。首先，在镜柜这里设计了一个插座，方便给剃须刀与电动牙刷充电，这是从齐洪海的分享中学到的。在沙发上方也设计了一个插座，这个插座使用频率还很高，因为位置比较方便。阳台这里也设计了一个插座，冬天在这里打手搓麻将时，可以插上小太阳暖脚，平时阳台用电脑时也可以充电。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="https://hexoblog.r2.depp.wang/46EC5279-B206-4D9C-B395-AF87DADAFCE4_1_105_c.jpeg" alt=""></td><td><img src="https://hexoblog.r2.depp.wang/9FF126B8-7F6F-4BB3-822E-C0B493A27094_1_105_c.jpeg" alt="">)<img src="https://hexoblog.r2.depp.wang/154D4840-284C-4140-9AA8-182F837D134A_1_105_c.jpeg" alt=""></td></tr></tbody></table><p>全屋智能这块其实设计也比较简单，主要分为 2 块，1 块是全屋 WIFI ，1 块是智能开关。</p><table><thead><tr><th>全屋 WIFI</th><th>智能开关</th></tr></thead><tbody><tr><td><img src="https://hexoblog.r2.depp.wang/20240527121026.png" alt=""></td><td><img src="https://hexoblog.r2.depp.wang/20240527121110.png" alt=""></td></tr></tbody></table><p>全屋 WIFI 是用的 Mesh 组网，效果就是有多个路由器，但只有一个 WIFI，根据你的位置它自动连接信号好的那个。</p><p>智能开关的好处是可以语音控制，也可以实现远程控制。我智能开关使用的是绿米的零火智能开关，我没有做双控，每个灯就一个开关，开关都是设计在进门的外面，进门可以手动开，关一般就用语音控制，买了个小爱触屏音箱。</p><p>智能家居我使用的米家生态，它的性价比高一点，可以接入设备也更多一点。部分设备也支持 HomeKit。</p><h2 id="入口设计"><a href="#入口设计" class="headerlink" title="入口设计"></a>入口设计</h2><p>齐洪海说设计入口的技术含量最高，我也比较认同。他列出了在入口会发生的一些行为和入口区域会储藏的一些物品。</p><p><img src="https://hexoblog.r2.depp.wang/7.jpg" alt=""></p><p>我家因为没有没有专门的玄关区域，所以无法实现太多的功能，比如放自行车等。但也尽力实现了一些功能。去掉了进门右手边这面墙的一半，拥有了一个 50cm 深的储藏空间，上部分放行李箱，中间做挂衣区，挂外出会穿的雨衣和外套，常用包与购物袋也会放这里，下面改造为会抽屉，放不常穿的鞋。柜门内嵌了一面镜子，但因为柜门的高度问题，镜子稍微有点矮。这里有个我觉得可以注意的点，如果你鞋柜留悬空区，悬空区不要太深了，跟你鞋长差不多就行，这样穿鞋比较方便。</p><table><thead><tr><th>入口</th><th>柜子</th></tr></thead><tbody><tr><td><img src="https://hexoblog.r2.depp.wang/41F1D5E0-0887-404F-A505-9EA2E8C141D1_1_105_c.jpeg" alt=""></td><td><img src="https://hexoblog.r2.depp.wang/697E2233-0A5E-41BD-A79A-CE603105FC5C_1_105_c.jpeg" alt=""></td></tr></tbody></table><p>入口区域我原来是一直想设计个可以坐着穿鞋的凳子的，但因为空间不太够用，最后就放弃了。现在觉得鞋凳确实也没有必要，一般也很少坐着穿鞋。但因为右边柜体深度只有 27cm 左右，所以鞋柜隔板只能倾斜，但悬空区域 27cm 深度对我来说刚刚好，我是 40 码的鞋。后面我的木工师傅告诉我，其实可以将墙体再打薄一点，这样鞋柜隔板就不用倾斜。</p><p>我在小红书上看到的这种餐桌可内嵌的餐边柜，比较适合我家入口这块区域，所以这块区域就采用了这个设计。</p><table><thead><tr><th>小红书餐边柜</th><th>餐边柜</th></tr></thead><tbody><tr><td><img src="https://hexoblog.r2.depp.wang/8.jpg" alt=""></td><td><img src="https://hexoblog.r2.depp.wang/328BBC07-1598-425E-827C-5751EA4E4DB0_1_105_c.jpeg" alt=""></td></tr></tbody></table><p>进门右边区域储藏放鞋等差不多，但出门运动的物品，比如篮球，还是没有地方放。所以运动物品就放到餐边柜左边的下半部分储藏空间中了。这里做了 2 个小的设计，一是为了拿取物品的方便，下面柜门的方向放到了外侧，而不是像正常的设计会放到桌子这侧边；二是为了减少碰撞的疼痛感，柜子的转角设计为了 R 角。</p><h2 id="卫生间与生活阳台设计"><a href="#卫生间与生活阳台设计" class="headerlink" title="卫生间与生活阳台设计"></a>卫生间与生活阳台设计</h2><p>卫生间与生活阳台我放在一起说，当我把卫生间与生活阳台打通后，正好实现了洗漱、如厕、洗浴、洗衣 4 个区域独立，但连到了一起，虽然没有日本「4 分离式卫生间」那么合理，但勉强算是 4 分离式卫生间。卫生间与生活阳台打通后也增加了便利性，比如洗澡前拿浴巾、洗澡后晾浴巾。如果你的卫生间与生活阳台挨在一起，卫生间不使用蹲便的话，我建议你打通。</p><table><thead><tr><th>日本 4 分离式卫生间</th><th>卫生间与生活阳台打通</th></tr></thead><tbody><tr><td><img src="https://hexoblog.r2.depp.wang/20240527171851.png" alt=""></td><td><img src="https://hexoblog.r2.depp.wang/20240527125044.png" alt=""></td></tr></tbody></table><p>生活阳台比较窄，只能 1 米宽，想在生活阳台设计一个洗衣台，如果用滚筒洗衣机的话，完全打开门需要 1 米以上的距离，所以只能竖着放，这样洗衣台只能放到洗衣机上面，但太高了，使用不方便。最后没有选择滚筒洗衣机而选择了波轮洗衣机，旁边买了成品的陶瓷洗衣台，媳妇儿非常喜欢这个洗衣台，现在我们洗漱洗头基本都使用的这个洗衣台。虽然现在很好用，但当时这块的水电设计一直不知道怎么做，一直阻塞工期，后面这个设计也是突然想到的。</p><p><img src="https://hexoblog.r2.depp.wang/50A49402-AF63-40EF-A7B6-FD63456FE1D4_1_105_c.jpeg" alt=""></p><p>生活阳台我选择了晾衣杆，而没有选择智能晾衣架，其实原因是因为生活阳台宽度太窄了，只有 1m，智能晾衣架放下来时需要在旁边晾衣服，宽度不够，所以就选择不了。</p><p><img src="https://hexoblog.r2.depp.wang/6A8D6C16-C553-41FB-9ACC-117CBB6DD0E5_1_105_c.jpeg" alt=""></p><p>个人觉得生活阳台还是非常重要的一个空间，晾点私人衣物，不用担心隐私问题。现在很多大户型也没有生活阳台了，有点倒行逆施了。</p><p>卫生间是按照设计师设计来装修的，淋浴区域当过道，不过门选择了外开，这样提升了过道的宽度，外开时， 也可以顺便保证生活阳台的隐私性。卫生间没有太多的储藏空间，餐边柜右边部分储藏空间分给了卫生间。</p><p><img src="https://hexoblog.r2.depp.wang/A714355E-F408-4529-A069-C5C62A6C5182_1_105_c.jpeg" alt=""></p><p>扫地机器人是设计放到卫生间洗漱柜下方的。没有做墙排，当时是我爸给我做的开槽，因为是承重墙，就没有开。</p><p><img src="https://hexoblog.r2.depp.wang/3CE6A8B4-2D82-4A98-A96C-0B9C8F0E44D7_1_105_c.jpeg" alt=""></p><h2 id="厨房设计"><a href="#厨房设计" class="headerlink" title="厨房设计"></a>厨房设计</h2><p>我这个户型大多数厨房因为没有封门，所以台面是一字型，我借生活阳台的空间将厨房其设计为 U 型，这样厨房台面变大了，储藏也基本够用了，生活阳台的空间也利用起来了，没有浪费。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="https://hexoblog.r2.depp.wang/38FC4467-60F9-4502-8A1E-FA356BFB20B2_1_105_c.jpeg" alt=""></td><td><img src="https://hexoblog.r2.depp.wang/C2A3D609-8ADE-49B3-B063-3495F180F655_1_105_c.jpeg" alt=""></td></tr></tbody></table><p>厨房设计了高低台，但因为燃气灶不能离台面太近，所以将抽屉与燃气灶错开了，抽屉没有居中。洗碗机上面的空间做了一个薄抽屉，平时放点筷子/勺子等还是挺好的。洗碗机这里插座没有设计好，跟左边燃气管处于了一个空间，为了安全，最后还是没有用，接的插线板，用的水槽下的插座。洗碗机入水管、电源线、排水管还是挺长的，不用挨得特别近，也不能设计到后面，这样会增加洗碗机的深度。</p><p><img src="https://hexoblog.r2.depp.wang/B6EAADE0-A3E2-4D25-B8D9-7272A7F1E636_1_105_c.jpeg" alt=""></p><p>U 型地柜这里也设计了很久，想如何能更好的利用这部分空间，最后还是选择的简单的结构。右边这部分可以正常使用。水槽下里面的空间，最里面放了净水器，现在还放了泡菜坛等一些东西，也算是利用起来了。原来专门给净水器设计了一个进水，最后也没有用上，净水器直接用二分转接头，和水槽龙头用的一个进水。</p><p><img src="https://hexoblog.r2.depp.wang/47DD741A-B053-4697-A781-C9198A47A96B_1_105_c.jpeg" alt=""></p><p>也模仿了一下小红书上的设计，留了个可以放手推车的柜子。</p><p><img src="https://hexoblog.r2.depp.wang/0DED9E79-E499-40D2-9A53-16381A292713_1_105_c.jpeg" alt=""></p><p>后面单独安装了一个调料柜，不少朋友都觉得还不错，开始觉得有点长，用起来后发现刚刚好。现在基本没有人用挡水条了，接缝我没有打玻璃胶，而是直接打的聚脲美缝剂，这是我的室内门师傅安利的，说不容易变黄发霉。</p><p><img src="https://hexoblog.r2.depp.wang/98DED783-6C62-4648-A90A-635519C43F99_1_105_c.jpeg" alt=""></p><p>厨房门的还有一个改动就是把门扩大了一点。原来只能一个人通过，现在基本可以两个人通过了。因为使用平开门会影响冰箱门的开关，所以用的滑轨门。</p><p><img src="https://hexoblog.r2.depp.wang/AD972C88-7DC2-496B-8038-75E81EBD7D42_1_105_c.jpeg" alt=""></p><h2 id="厅设计"><a href="#厅设计" class="headerlink" title="厅设计"></a>厅设计</h2><p>齐洪海的客厅采用的书桌加书架的方式，这种格局比较适合家里小孩大了的时候。对于我来说还不太适合，还是采用了原始的沙发 + 电视柜的格局。沙发建议越小越好，越小越显空间大，我这个沙发是 2.3m。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="https://hexoblog.r2.depp.wang/51D855FF-DE34-447D-A353-F2F32E602400_1_105_c.jpeg" alt=""></td><td><img src="https://hexoblog.r2.depp.wang/05BCD90F-E2F5-405D-9642-08AB9B773310_1_105_c.jpeg" alt=""></td></tr></tbody></table><p>我电视柜右侧没有跟墙齐平，而是在右边留了几个插座，这样空出来一点空间，也可以放点绿植。</p><p>因为噪音问题，阳台还是选择的平开窗，没有选择滑窗。如果没有噪音问题，滑窗其实也不错，有更好的通风性，更低的价格。</p><p>因为平时白天也基本不看电视，所以客厅使用的投影仪。我没给投影仪预留 HDMI 线，而是预留了一根网线，我将 Apple TV 直接与投影仪放一起，使用 HDMI 线连接，Apple TV 有线联网。</p><p>投影仪我没有用幕布，好的幕布挺贵，而晚上不用幕布效果也挺好。安装投影仪，还是需要安装一个布帘，白天想用投影仪，拉上布帘，效果也还是可以。</p><p><img src="https://hexoblog.r2.depp.wang/B4037EBB-C167-4083-9A2E-96792A9D298D_1_105_c.jpeg" alt=""></p><p>阳台的空调洞参考小红书的设计将其设计为了置物格了，想打开的时候也可以拆下来。</p><p><img src="https://hexoblog.r2.depp.wang/FD245130-00DD-4AA4-8745-AEA81C8DA0D5_1_105_c.jpeg" alt=""></p><h2 id="卧室设计"><a href="#卧室设计" class="headerlink" title="卧室设计"></a>卧室设计</h2><p>原来一直是租房，衣柜空间一直不够用。自己装修成功实现了 2 个 1.6 的大衣柜，衣服终于不用来回倒腾了。衣柜除了最上面的空间，其它都是挂衣区与抽屉。都没有做免拉手，还是用了拉手，也没有要一门到顶，现在觉得是正确的选择。</p><p><img src="https://hexoblog.r2.depp.wang/F598F4A4-62D5-49E7-AA22-7DD3F36BE84E_1_105_c.jpeg" alt=""></p><p>床头灯这里，原来设计的吊灯，后面想到吊灯会挡空调，所以又改为了壁灯。空调买的小米新风空调，带有新风功能。</p><p><img src="https://hexoblog.r2.depp.wang/51C8665A-CCDC-409C-AE1A-0C4154C01A2A_1_105_c.jpeg" alt=""></p><p>我客厅是用的风管机，两个卧室使用的挂机，有 3 个空调外机，次卧这里原来有个空调机位，我看小区里面不少人家在客厅空调机位这一个位置放了 3 个空调外机，因为放得下，所以我将次卧空调机位取消了，将 3 个空调外机也放到一起。次卧空调铜管从主卧穿过，需在木工前预埋。这让次卧窗户外移了几十厘米，让室内使用面积多了接近一个平方。空调机位空出来的地方做了个地柜。做这个地柜遇到不少麻烦，现在还是很香，平时放些不常用的东西。</p><p><img src="https://hexoblog.r2.depp.wang/9B07AB7A-D37A-4122-B7F0-F36F435564ED_1_105_c.jpeg" alt=""></p><p>我的次卧书桌没有抽屉，这样带扶手的椅子也可以放下面，坐感更舒适。整体使用不错，但高度没有考虑好，现在觉得书桌稍微有点高了。</p><p>书桌设计的 L 型，开始想做 L 型，第一家全屋定制也说他们不能做，需要自己烧钢架才行，后面找的这家全屋定制使用一根钢管就解决了这个问题。</p><p>旁边设计了一个可站立办公柜子，设计了 2 个可储物的抽屉，用于弥补旁边书桌没有抽屉的问题。</p><p><img src="https://hexoblog.r2.depp.wang/F5937B09-E832-4D37-A0F3-4E04999FCF40_1_105_c.jpeg" alt=""></p><p>因为次卧床靠墙，里面不能放床头柜，所以买了这种床头可以储物的床。</p><p><img src="https://hexoblog.r2.depp.wang/DCB817E7-31A0-4F57-B216-46596501B6B1_1_105_c.jpeg" alt=""></p><h2 id="装修的个人感受"><a href="#装修的个人感受" class="headerlink" title="装修的个人感受"></a>装修的个人感受</h2><p>以上我的所有关于装修设计的分享，再谈点我关于装修的个人感受。</p><p>如果你像我一样户型不好，那么通过设计让空间利用率更高、功能实用性更好就更有必要，如果破罐子破摔，就更加浪费了房子的价值。</p><p>装修其实是将房子升值的过程，房子可能有很多问题，但很多问题可以通过装修设计来解决。有噪音，安隔音窗；隐私性不好，安纱帘，安智能窗帘；户型不好，改户型。我们不能解决房子外面的问题，比如朝向问题、位置问题，但我们可以解决房子里面的问题。装修设计时辛苦一点，换来的是更好的居住体验。</p><p>我还写了其它的<a href="https://depp.wang/tags/%E8%A3%85%E4%BF%AE/">一些装修文章</a>。如果还想看我分享更多关于装修方向的经验，如装修费用、装修踩坑等方面，欢迎留言。</p>]]></content:encoded>
      
      <comments>https://depp.wang/2024/decoration-design/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
